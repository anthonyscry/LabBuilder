---
phase: 01-project-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - SimpleLab/Private/Write-RunArtifact.ps1
  - SimpleLab/Private/Get-HostInfo.ps1
  - SimpleLab/SimpleLab.psm1
  - SimpleLab/.planning/runs/ (directory created dynamically)
autonomous: true

must_haves:
  truths:
    - "Write-RunArtifact function generates timestamped JSON files in .planning/runs/ directory"
    - "JSON files contain all required fields: Operation, Timestamp, Status, Duration, Error (if any), VM names, Phase info, Host info"
    - "Run artifacts are created even when operations fail (generated in finally block pattern)"
    - "JSON uses proper depth parameter to avoid truncation"
    - ".planning/runs/ directory is created automatically if it doesn't exist"
  artifacts:
    - path: "SimpleLab/Private/Write-RunArtifact.ps1"
      provides: "JSON run artifact generation function"
      contains: "ConvertTo-Json", "New-Item", "Out-File", "-Depth"
      min_lines: 50
    - path: "SimpleLab/Private/Get-HostInfo.ps1"
      provides: "Host information collection for run artifacts"
      contains: "$env:COMPUTERNAME", "$env:USERNAME", "$PSVersionTable"
    - path: ".planning/runs/"
      provides: "Directory for timestamped run artifact JSON files"
  key_links:
    - from: "SimpleLab/Private/Write-RunArtifact.ps1"
      to: ".planning/runs/run-*.json"
      via: "Out-File with UTF-8 encoding and timestamp in filename"
      pattern: "Out-File.*run-.*\\.json"
    - from: "SimpleLab/Private/Write-RunArtifact.ps1"
      to: "ConvertTo-Json cmdlet"
      via: "JSON serialization with -Depth 4 parameter"
      pattern: "ConvertTo-Json.*-Depth"
    - from: "SimpleLab/Private/Get-HostInfo.ps1"
      to: "Write-RunArtifact"
      via: "Function call to populate HostInfo field"
      pattern: "Get-HostInfo"
---

<objective>
Implement JSON run artifact generation system that creates timestamped records of every operation. This addresses UX-03 requirement for operation reports.

Purpose: Generate JSON run artifacts after each operation containing operation type, timestamp, status, duration, and error information.
Output: Working Write-RunArtifact function that creates .planning/runs/run-YYYYMMDD-HHMMSS.json files with complete operation data.
</objective>

<execution_context>
@/home/ajt/.claude/get-shit-done/workflows/execute-plan.md
@/home/ajt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-foundation/01-CONTEXT.md
@.planning/phases/01-project-foundation/01-RESEARCH.md

# Locked decisions from CONTEXT.md
- Store as timestamped files (one per run): `run-YYYYMMDD-HHMMSS.json`
- Location: `.planning/runs/` directory
- Fields: Operation, Timestamp, Status, Duration, Error (if any), VM names, Phase info, Host info
- Use [ordered]@{} for hashtables when order matters (Claude's discretion)

# Research reference
Pattern 3: JSON Run Artifact Generation (RESEARCH.md lines 184-244)
Pitfall 3: JSON Depth Limitations (RESEARCH.md lines 333-343)
Pitfall 5: Hashtables vs PSCustomObject for JSON (RESEARCH.md lines 357-377)
</context>

<tasks>

<task type="auto">
  <name>Implement Get-HostInfo function</name>
  <files>SimpleLab/Private/Get-HostInfo.ps1</files>
  <action>
Replace the stub in Private/Get-HostInfo.ps1 with full implementation:

```powershell
function Get-HostInfo {
    [CmdletBinding()]
    [OutputType([hashtable])]
    param()

    return [ordered]@{
        ComputerName = $env:COMPUTERNAME
        Username = $env:USERNAME
        PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        OS = $env:OS
        IsWindows = if ($IsWindows -eq $null) { $env:OS -eq 'Windows_NT' } else { $IsWindows }
    }
}
```

Uses [ordered]@{} per RESEARCH.md Pitfall 5 guidance to preserve JSON property order. Includes fields relevant to run artifact context.
  </action>
  <verify>
Run: Import-Module ./SimpleLab/SimpleLab.psd1 -Force
Then: $info = Get-HostInfo
Expected: Hashtable with keys ComputerName, Username, PowerShellVersion, OS, IsWindows
  </verify>
  <done>Function returns ordered hashtable with host information</done>
</task>

<task type="auto">
  <name>Implement Write-RunArtifact function with JSON generation</name>
  <files>SimpleLab/Private/Write-RunArtifact.ps1</files>
  <action>
Replace the stub in Private/Write-RunArtifact.ps1 with full implementation:

```powershell
function Write-RunArtifact {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Operation,

        [Parameter(Mandatory)]
        [string]$Status,

        [Parameter(Mandatory)]
        [double]$Duration,

        [Parameter(Mandatory)]
        [int]$ExitCode,

        [string[]]$VMNames = @(),

        [string]$Phase = "01-project-foundation",

        [Management.Automation.ErrorRecord]$ErrorRecord
    )

    try {
        # Generate timestamp for filename and ISO 8601 timestamp for content
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $isoTimestamp = (Get-Date).ToString("o")

        # Determine artifact path relative to repository root
        # $PSScriptRoot is SimpleLab/ directory, so we go up one level
        $artifactDir = Join-Path $PSScriptRoot "..\.planning\runs"
        $artifactDir = Resolve-Path $artifactDir -ErrorAction SilentlyContinue

        if (-not $artifactDir) {
            # Create directory if it doesn't exist
            $artifactDir = New-Item -Path (Join-Path $PSScriptRoot "..\.planning\runs") -ItemType Directory -Force
            $artifactDir = $artifactDir.FullName
        }

        $artifactPath = Join-Path $artifactDir "run-$timestamp.json"

        # Build artifact object using [ordered] hashtable for consistent property order
        $artifact = [ordered]@{
            Operation = $Operation
            Timestamp = $isoTimestamp
            Status = $Status
            Duration = $Duration
            ExitCode = $ExitCode
            VMNames = @($VMNames)  # Ensure array type
            Phase = $Phase
            HostInfo = Get-HostInfo
        }

        # Add error information if present
        if ($ErrorRecord) {
            $artifact.Error = [ordered]@{
                Message = $ErrorRecord.Exception.Message
                Type = $ErrorRecord.Exception.GetType().FullName
                ScriptStackTrace = $ErrorRecord.ScriptStackTrace
            }
        }

        # Convert to JSON with proper depth (avoid truncation per Pitfall 3)
        $json = $artifact | ConvertTo-Json -Depth 4

        # Write to file
        $json | Out-File -FilePath $artifactPath -Encoding utf8 -Force

        Write-Host "Run artifact saved to: $artifactPath"

        return $artifactPath
    }
    catch {
        Write-Error "Failed to write run artifact: $($_.Exception.Message)"
        return $null
    }
}
```

Key implementation notes:
- Uses [ordered]@{} for consistent JSON property order
- Uses -Depth 4 to avoid truncation (Pitfall 3 from RESEARCH.md)
- Creates .planning/runs/ directory automatically if missing
- Timestamp in filename (yyyyMMdd-HHmmss) and ISO 8601 in content
- Handles ErrorRecord parameter for error details when present
  </action>
  <verify>
Run: Import-Module ./SimpleLab/SimpleLab.psd1 -Force
Then: Write-RunArtifact -Operation "Test" -Status "Success" -Duration 1.5 -ExitCode 0
Expected: .planning/runs/run-*.json file created with valid JSON containing all fields
Verify: Get-Content .planning/runs/run-*.json | ConvertFrom-Json returns object with Operation, Timestamp, Status, Duration, ExitCode, HostInfo properties
  </verify>
  <done>Function creates timestamped JSON files with complete operation data</done>
</task>

<task type="auto">
  <name>Create SimpleLab.ps1 entry point script with error handling demo</name>
  <files>SimpleLab/SimpleLab.ps1</files>
  <action>
Create SimpleLab/SimpleLab.ps1 as the main entry point script that demonstrates structured error handling and run artifact generation:

```powershell
# SimpleLab.ps1
# Main entry point for SimpleLab operations

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [ValidateSet('Test-HyperV', 'Test-Artifact')]
    [string]$Operation = 'Test-HyperV'
)

$ErrorActionPreference = 'Stop'
$startTime = Get-Date
$exitCode = 0
$vmNames = @()

try {
    Write-Host "SimpleLab v0.1.0 - Starting operation: $Operation" -ForegroundColor Cyan

    # Import module
    $modulePath = Join-Path $PSScriptRoot 'SimpleLab.psd1'
    Import-Module $modulePath -Force -ErrorAction Stop

    # Check Hyper-V first (per user decision: check on every operation)
    Write-Host "Checking Hyper-V availability..."
    if (-not (Test-HyperVEnabled)) {
        $exitCode = 2  # Validation failure
        throw "Hyper-V validation failed"
    }

    # Perform operation
    switch ($Operation) {
        'Test-HyperV' {
            Write-Host "Hyper-V is available and enabled" -ForegroundColor Green
            $status = "Success"
        }
        'Test-Artifact' {
            Write-Host "Testing run artifact generation..."
            $status = "Success"
        }
        default {
            throw "Unknown operation: $Operation"
        }
    }
}
catch {
    # Surface the error
    Write-Error "Operation failed: $($_.Exception.Message)"

    # Set appropriate exit code based on error type
    if ($_.Exception.Message -match "network") { $exitCode = 3 }
    elseif ($_.Exception.Message -match "VM") { $exitCode = 4 }
    elseif ($_.Exception.Message -match "domain") { $exitCode = 5 }
    else { $exitCode = 1 }

    $status = "Failed"
}
finally {
    # Always generate run artifact (per user decision)
    $duration = (Get-Date - $startTime).TotalSeconds
    $errorRecord = if ($exitCode -ne 0) { $_ } else { $null }

    Write-RunArtifact -Operation $Operation -Status $status -Duration $duration -ExitCode $exitCode -VMNames $vmNames -ErrorRecord $errorRecord
}

exit $exitCode
```

This demonstrates the complete error handling pattern per RESEARCH.md Pattern 2:
- $ErrorActionPreference = 'Stop'
- try/catch/finally structure
- Granular exit codes (1=general, 2=validation, 3=network, 4=VM, 5=domain)
- Run artifact in finally block (always generated)
  </action>
  <verify>
Run: .\SimpleLab\SimpleLab.ps1 -Operation Test-HyperV
Expected: Hyper-V check runs, artifact generated in .planning/runs/, appropriate exit code
Then: Get-Content .planning/runs/run-*.json | ConvertFrom-Json
Expected: Object with Operation="Test-HyperV", Status="Success" or "Failed", Duration > 0
  </verify>
  <done>Entry point script demonstrates complete error handling and artifact generation</done>
</task>

<task type="auto">
  <name>Update SimpleLab.psm1 to export Write-RunArtifact</name>
  <files>SimpleLab/SimpleLab.psm1</files>
  <action>
Modify the Export-ModuleMember line in SimpleLab.psm1 to include Write-RunArtifact:

Change:
```powershell
Export-ModuleMember -Function @(
    'Test-HyperVEnabled'
)
```

To:
```powershell
Export-ModuleMember -Function @(
    'Test-HyperVEnabled',
    'Write-RunArtifact'
)
```

This makes Write-RunArtifact callable from SimpleLab.ps1 entry point script.
  </action>
  <verify>Get-Command -Module SimpleLab shows both Test-HyperVEnabled and Write-RunArtifact</verify>
  <done>Write-RunArtifact is exported and callable from entry point script</done>
</task>

</tasks>

<verification>
1. Run artifact creation: `.\SimpleLab\SimpleLab.ps1 -Operation Test-HyperV` creates .planning/runs/run-*.json
2. JSON validation: File contains all required fields (Operation, Timestamp, Status, Duration, ExitCode, VMNames, Phase, HostInfo)
3. JSON depth: Complex nested objects (HostInfo, Error) are not truncated
4. Timestamp format: Filename uses yyyyMMdd-HHmmss, content uses ISO 8601
5. Error artifact: Run with Hyper-V disabled creates artifact with Error field populated
6. Finally block: Artifact created even when operation fails
</verification>

<success_criteria>
1. Write-RunArtifact function creates .planning/runs/run-YYYYMMDD-HHMMSS.json files
2. JSON files contain all required fields per CONTEXT.md decision
3. JSON uses -Depth 4 to avoid truncation
4. Artifacts created in finally block (always generated)
5. Entry point script demonstrates complete error handling pattern
6. Exit codes are granular (1=general, 2=validation, 3=network, 4=VM, 5=domain)
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation/01-03-SUMMARY.md` with:
- Actual JSON schema produced
- Sample run artifact content
- Test results from SimpleLab.ps1 entry point
- Any deviations from expected schema
- Phase 1 completion status
</output>
