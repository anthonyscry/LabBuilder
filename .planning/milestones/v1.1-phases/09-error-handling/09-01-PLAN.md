---
phase: 09-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Private/Invoke-LabOrchestrationActionCore.ps1
  - Private/Invoke-LabOneButtonReset.ps1
  - Private/Invoke-LabSetup.ps1
  - Private/Invoke-LabQuickDeploy.ps1
  - Private/Invoke-LabLogRetention.ps1
  - Private/Import-LabScriptTree.ps1
  - Private/Ensure-VMsReady.ps1
  - Private/Clear-LabSSHKnownHosts.ps1
  - Private/Write-LabRunArtifacts.ps1
  - Private/New-LabDeploymentReport.ps1
  - Tests/ErrorHandling-Batch1.Tests.ps1
autonomous: true
requirements:
  - ERR-01
  - ERR-03

must_haves:
  truths:
    - "All 10 orchestration and lifecycle Private functions have outer try-catch blocks"
    - "Error messages include the function name as a prefix for grep-ability"
    - "Functions use $PSCmdlet.WriteError() for non-terminating errors where callers should decide severity"
    - "Functions that must halt use throw (Ensure-VMsReady, Import-LabScriptTree)"
    - "All existing Pester tests pass after changes (no behavior regression)"
  artifacts:
    - path: "Private/Invoke-LabOrchestrationActionCore.ps1"
      provides: "try-catch wrapping action routing"
    - path: "Private/Write-LabRunArtifacts.ps1"
      provides: "try-catch wrapping file I/O for run artifacts"
    - path: "Tests/ErrorHandling-Batch1.Tests.ps1"
      provides: "Tests verifying error handling pattern for all 10 functions"
  key_links:
    - from: "Private/Invoke-LabOrchestrationActionCore.ps1"
      to: "Invoke-LabQuickDeploy.ps1"
      via: "routes actions through sub-functions"
      pattern: "try.*catch"
---

<objective>
Add try-catch error handling to 10 Private orchestration and lifecycle functions (Batch 1 of 4).

Purpose: These functions coordinate lab operations (setup, deploy, reset, teardown) and are the most critical path for user-facing errors. Adding structured error handling ensures failures produce actionable messages instead of raw stack traces.

Output: 10 updated Private/*.ps1 files with try-catch, plus ErrorHandling-Batch1.Tests.ps1 verifying the pattern.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-error-handling/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add try-catch to orchestration functions (5 files)</name>
  <files>Private/Invoke-LabOrchestrationActionCore.ps1, Private/Invoke-LabOneButtonReset.ps1, Private/Invoke-LabSetup.ps1, Private/Invoke-LabQuickDeploy.ps1, Private/Invoke-LabLogRetention.ps1</files>
  <action>
    Wrap the function body (everything after param block) in a try-catch block for each file.

    **Pattern for non-terminating errors (Invoke-LabOrchestrationActionCore, Invoke-LabOneButtonReset, Invoke-LabLogRetention):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        $PSCmdlet.WriteError(
            [System.Management.Automation.ErrorRecord]::new(
                [System.Exception]::new("FunctionName: <context> - $_", $_.Exception),
                'FunctionName.Failure',
                [System.Management.Automation.ErrorCategory]::NotSpecified,
                $null
            )
        )
    }
    ```

    **Pattern for terminating errors (Invoke-LabSetup, Invoke-LabQuickDeploy -- failures should halt pipeline):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        throw "FunctionName: <context> - $_"
    }
    ```

    Context messages:
    - Invoke-LabOrchestrationActionCore: "failed to execute action '$Action'"
    - Invoke-LabOneButtonReset: "reset operation failed"
    - Invoke-LabSetup: "setup failed during script execution"
    - Invoke-LabQuickDeploy: "quick deploy failed"
    - Invoke-LabLogRetention: "log retention cleanup failed for '$LogRoot'"
  </action>
  <verify>
    Dot-source each file and verify the function body contains try-catch:
    ```powershell
    foreach ($f in @('Invoke-LabOrchestrationActionCore','Invoke-LabOneButtonReset','Invoke-LabSetup','Invoke-LabQuickDeploy','Invoke-LabLogRetention')) {
        $content = Get-Content "Private/$f.ps1" -Raw
        $content | Should -Match 'try\s*\{'
        $content | Should -Match 'catch\s*\{'
        $content | Should -Match "$f`:"
    }
    ```
  </verify>
  <done>5 orchestration functions have try-catch with function-name-prefixed error messages.</done>
</task>

<task type="auto">
  <name>Task 2: Add try-catch to infrastructure functions (5 files)</name>
  <files>Private/Import-LabScriptTree.ps1, Private/Ensure-VMsReady.ps1, Private/Clear-LabSSHKnownHosts.ps1, Private/Write-LabRunArtifacts.ps1, Private/New-LabDeploymentReport.ps1</files>
  <action>
    Wrap the function body in try-catch for each file.

    **Pattern for terminating errors (Import-LabScriptTree, Ensure-VMsReady -- script loading and VM readiness failures are fatal):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        throw "FunctionName: <context> - $_"
    }
    ```

    **Pattern for non-terminating errors (Clear-LabSSHKnownHosts, Write-LabRunArtifacts, New-LabDeploymentReport -- non-critical side effects):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        $PSCmdlet.WriteError(
            [System.Management.Automation.ErrorRecord]::new(
                [System.Exception]::new("FunctionName: <context> - $_", $_.Exception),
                'FunctionName.Failure',
                [System.Management.Automation.ErrorCategory]::NotSpecified,
                $null
            )
        )
    }
    ```

    Context messages:
    - Import-LabScriptTree: "failed to load scripts from '$RootPath'"
    - Ensure-VMsReady: "VM readiness check failed"
    - Clear-LabSSHKnownHosts: "failed to clear SSH known hosts"
    - Write-LabRunArtifacts: "failed to write run artifacts to '$RunLogDir'"
    - New-LabDeploymentReport: "failed to generate deployment report"
  </action>
  <verify>
    Check each file contains try-catch with function name in error message.
  </verify>
  <done>5 infrastructure functions have try-catch with function-name-prefixed error messages.</done>
</task>

<task type="auto">
  <name>Task 3: Create ErrorHandling-Batch1.Tests.ps1</name>
  <files>Tests/ErrorHandling-Batch1.Tests.ps1</files>
  <action>
    Create a Pester 5.x test file that verifies all 10 functions have try-catch with proper error message patterns.

    **Test structure:**
    ```powershell
    BeforeAll {
        Set-StrictMode -Version Latest
    }

    Describe 'Error Handling - Batch 1: Orchestration & Lifecycle' {
        $functions = @(
            'Private/Invoke-LabOrchestrationActionCore.ps1',
            'Private/Invoke-LabOneButtonReset.ps1',
            'Private/Invoke-LabSetup.ps1',
            'Private/Invoke-LabQuickDeploy.ps1',
            'Private/Invoke-LabLogRetention.ps1',
            'Private/Import-LabScriptTree.ps1',
            'Private/Ensure-VMsReady.ps1',
            'Private/Clear-LabSSHKnownHosts.ps1',
            'Private/Write-LabRunArtifacts.ps1',
            'Private/New-LabDeploymentReport.ps1'
        )

        foreach ($file in $functions) {
            $funcName = [IO.Path]::GetFileNameWithoutExtension($file)
            $filePath = Join-Path $PSScriptRoot "..\$file"

            It "$funcName has try-catch error handling" {
                $content = Get-Content $filePath -Raw
                $content | Should -Match 'try\s*\{' -Because "$funcName must have try-catch"
                $content | Should -Match 'catch\s*\{' -Because "$funcName must have catch block"
            }

            It "$funcName error message includes function name" {
                $content = Get-Content $filePath -Raw
                $content | Should -Match ([regex]::Escape($funcName) + ':') -Because "error messages must include function name for grep-ability (ERR-03)"
            }
        }
    }
    ```

    Use `Set-StrictMode -Version Latest` in BeforeAll. Follow project test patterns.
  </action>
  <verify>
    Run the test file:
    ```powershell
    Invoke-Pester Tests/ErrorHandling-Batch1.Tests.ps1 -Output Detailed
    ```
    All tests pass.
  </verify>
  <done>ErrorHandling-Batch1.Tests.ps1 exists with tests for all 10 functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `Invoke-Pester Tests/ErrorHandling-Batch1.Tests.ps1 -Output Detailed` -- all tests pass
2. `Select-String -Path Private/Invoke-LabOrchestrationActionCore.ps1 -Pattern 'try'` -- matches
3. Full test suite: `Invoke-Pester Tests/ -Output Detailed` -- no regressions
4. All 10 files have try-catch: `Get-ChildItem Private/*.ps1 | Where-Object { $_.Name -in @(...) } | ForEach-Object { Select-String -Path $_.FullName -Pattern 'try\s*\{' }`
</verification>

<success_criteria>
- All 10 orchestration and lifecycle Private functions have try-catch error handling
- Error messages include function name prefix (ERR-03)
- Non-critical functions use $PSCmdlet.WriteError, critical functions use throw
- Full test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-error-handling/09-01-SUMMARY.md`
</output>
