---
phase: 26-lab-ttl-lifecycle-monitoring
plan: 03
type: tdd
wave: 2
depends_on: [01, 02]
files_modified:
  - Private/Invoke-LabTTLMonitor.ps1
  - Public/Get-LabUptime.ps1
  - Public/Reset-Lab.ps1
  - Tests/LabTTLMonitor.Tests.ps1
  - Tests/LabUptime.Tests.ps1
autonomous: true
requirements: [TTL-02, TTL-03]
must_haves:
  truths:
    - "When TTL expires the monitor saves or stops all running lab VMs based on configured Action"
    - "WallClockHours expiry triggers when elapsed time exceeds configured limit"
    - "IdleMinutes expiry triggers when all VMs have been running untouched beyond threshold"
    - "Monitor writes state to lab-ttl-state.json after each check"
    - "Get-LabUptime returns lab start time, elapsed hours, and TTL remaining"
    - "Get-LabUptime returns empty array when no lab is running"
    - "Reset-Lab calls Unregister-LabTTLTask during teardown"
    - "No orphaned scheduled tasks remain after lab teardown"
  artifacts:
    - path: "Private/Invoke-LabTTLMonitor.ps1"
      provides: "TTL check and enforcement logic"
      exports: ["Invoke-LabTTLMonitor"]
    - path: "Public/Get-LabUptime.ps1"
      provides: "Lab uptime and TTL status query"
      exports: ["Get-LabUptime"]
    - path: "Tests/LabTTLMonitor.Tests.ps1"
      provides: "Unit tests for TTL monitor"
      min_lines: 100
    - path: "Tests/LabUptime.Tests.ps1"
      provides: "Unit tests for uptime query"
      min_lines: 60
  key_links:
    - from: "Private/Invoke-LabTTLMonitor.ps1"
      to: "Private/Get-LabTTLConfig.ps1"
      via: "Reads TTL configuration"
      pattern: "Get-LabTTLConfig"
    - from: "Private/Invoke-LabTTLMonitor.ps1"
      to: ".planning/lab-ttl-state.json"
      via: "Writes state cache on each check"
      pattern: "lab-ttl-state\\.json"
    - from: "Public/Get-LabUptime.ps1"
      to: ".planning/lab-ttl-state.json"
      via: "Reads cached state for TTL status"
      pattern: "lab-ttl-state\\.json"
    - from: "Public/Reset-Lab.ps1"
      to: "Private/Unregister-LabTTLTask.ps1"
      via: "Calls unregister during teardown"
      pattern: "Unregister-LabTTLTask"
---

<objective>
Implement TTL monitor logic, uptime query function, and teardown integration.

Purpose: Completes the TTL feature end-to-end. The monitor checks wall-clock and idle thresholds, saves/stops VMs on expiry, and caches state. Get-LabUptime gives operators real-time TTL visibility. Reset-Lab integration ensures no orphaned tasks.
Output: Invoke-LabTTLMonitor.ps1, Get-LabUptime.ps1, Reset-Lab.ps1 updated, comprehensive tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/26-lab-ttl-lifecycle-monitoring/26-RESEARCH.md
@.planning/phases/26-lab-ttl-lifecycle-monitoring/26-01-SUMMARY.md
@.planning/phases/26-lab-ttl-lifecycle-monitoring/26-02-SUMMARY.md
@Private/Invoke-LabQuickModeHeal.ps1
@Private/Get-LabTTLConfig.ps1
@Private/Unregister-LabTTLTask.ps1
@Public/Reset-Lab.ps1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Invoke-LabTTLMonitor with TDD</name>
  <files>Private/Invoke-LabTTLMonitor.ps1, Tests/LabTTLMonitor.Tests.ps1</files>
  <action>
**RED phase — write tests first** in Tests/LabTTLMonitor.Tests.ps1:

Test file structure:
```powershell
BeforeAll {
    $repoRoot = Split-Path -Parent $PSScriptRoot
    . (Join-Path $repoRoot 'Private/Get-LabTTLConfig.ps1')
    . (Join-Path $repoRoot 'Private/Invoke-LabTTLMonitor.ps1')
}
```

Mock strategy: Define stub functions for Get-VM, Save-VM, Stop-VM, Get-LabTTLConfig, Set-Content, Get-Content in BeforeEach. Use `$script:` scoped tracking variables.

**Core test cases:**
1. Returns no-op result when TTL is disabled (Enabled=$false)
2. Returns no-op when no lab VMs exist (Get-VM returns empty)
3. Detects wall-clock expiry when elapsed hours exceed WallClockHours
4. Does NOT trigger when wall-clock is within limit
5. Detects idle expiry when all VMs running beyond IdleMinutes threshold
6. Does NOT trigger idle when IdleMinutes is 0 (disabled)
7. Calls Save-VM on each running VM when Action is 'Suspend' and TTL expired
8. Calls Stop-VM -Force on each running VM when Action is 'Off' and TTL expired
9. Skips VMs not in 'Running' state (already saved/stopped)
10. Returns audit result: TTLExpired, ActionAttempted, ActionSucceeded, VMsProcessed, RemainingIssues, DurationSeconds
11. Writes state JSON to configured path after each check
12. Handles Save-VM failure gracefully — adds to RemainingIssues, continues other VMs
13. Either trigger (wall-clock OR idle) causes expiry — whichever fires first

**GREEN phase — create Private/Invoke-LabTTLMonitor.ps1:**

Follow Invoke-LabQuickModeHeal pattern exactly:
- [CmdletBinding()] with param block
- No-op early return when disabled
- Try-catch around each VM action
- List[string] for repairs and remaining issues
- Duration tracking with Get-Date arithmetic
- Return [pscustomobject] audit trail

Parameters:
- `[string]$StatePath` — path to lab-ttl-state.json (default: Join-Path (Join-Path $PSScriptRoot '..') '.planning/lab-ttl-state.json')
- `[datetime]$LabStartTime` — override for testability (default: read from state JSON or current time)

Logic flow:
1. Call Get-LabTTLConfig — exit early if not Enabled
2. Read existing state JSON if exists (for StartTime)
3. Get lab VMs via Get-VM (filter to lab VMs using $GlobalLabConfig.Lab.CoreVMNames if available)
4. Check wall-clock: `(Get-Date) - $startTime` vs WallClockHours
5. Check idle: compare each running VM uptime against IdleMinutes (if IdleMinutes > 0)
6. If either expired: iterate running VMs, apply Action (Save-VM or Stop-VM -Force)
7. Build VM states hashtable (name -> state string)
8. Write state JSON: LabName, LastChecked, StartTime, TTLExpired, VMStates
9. Return audit PSCustomObject

Use Write-Warning for expiry/failure messages (prefix: `[TTLMonitor]`). Use Write-Verbose for routine check messages.

**REFACTOR:** Ensure consistent error handling, clean test isolation.
  </action>
  <verify>Run `pwsh -NoProfile -Command "Invoke-Pester Tests/LabTTLMonitor.Tests.ps1 -Output Detailed"` — all tests pass.</verify>
  <done>Invoke-LabTTLMonitor checks wall-clock and idle thresholds, applies configured action to running VMs, writes state cache, returns audit object. 13+ tests passing.</done>
</task>

<task type="auto">
  <name>Task 2: Create Get-LabUptime and integrate teardown hook</name>
  <files>Public/Get-LabUptime.ps1, Public/Reset-Lab.ps1, Tests/LabUptime.Tests.ps1</files>
  <action>
**RED phase — write tests first** in Tests/LabUptime.Tests.ps1:

Test file structure:
```powershell
BeforeAll {
    $repoRoot = Split-Path -Parent $PSScriptRoot
    . (Join-Path $repoRoot 'Private/Get-LabTTLConfig.ps1')
    . (Join-Path $repoRoot 'Public/Get-LabUptime.ps1')
}
```

**Get-LabUptime test cases:**
1. Returns empty array when no lab is running (no VMs found)
2. Returns PSCustomObject with correct fields: LabName, StartTime, ElapsedHours, TTLConfigured, TTLRemainingMinutes, Action, Status
3. ElapsedHours rounded to 1 decimal place
4. TTLRemainingMinutes is -1 when TTL not configured
5. TTLRemainingMinutes calculated correctly when TTL configured (WallClockHours * 60 - elapsed minutes)
6. Status is 'Active' when lab running and TTL not expired
7. Status is 'Expired' when TTL has expired
8. Status is 'Disabled' when TTL feature is disabled
9. Reads from cached state JSON when available
10. Falls back to live VM query when state JSON missing

**GREEN phase — create Public/Get-LabUptime.ps1:**

```powershell
function Get-LabUptime {
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [string]$StatePath
    )

    # Determine state path
    if (-not $StatePath) {
        $planningDir = Join-Path (Split-Path -Parent $PSScriptRoot) '.planning'
        $StatePath = Join-Path $planningDir 'lab-ttl-state.json'
    }

    # Check for running VMs
    $labVMs = @(Get-VM -ErrorAction SilentlyContinue)
    if ($labVMs.Count -eq 0) { return @() }

    $config = Get-LabTTLConfig
    $labName = if (Test-Path variable:GlobalLabConfig) {
        if ($GlobalLabConfig.ContainsKey('Lab') -and $GlobalLabConfig.Lab.ContainsKey('Name')) {
            $GlobalLabConfig.Lab.Name
        } else { 'Lab' }
    } else { 'Lab' }

    # Try cached state first
    $startTime = Get-Date
    $ttlExpired = $false
    if (Test-Path $StatePath) {
        try {
            $cached = Get-Content -Path $StatePath -Raw | ConvertFrom-Json
            if ($cached.StartTime) { $startTime = [datetime]$cached.StartTime }
            if ($null -ne $cached.TTLExpired) { $ttlExpired = [bool]$cached.TTLExpired }
        }
        catch { <# fall through to defaults #> }
    }

    $elapsed = (Get-Date) - $startTime
    $elapsedHours = [math]::Round($elapsed.TotalHours, 1)

    $ttlConfigured = $config.Enabled
    $ttlRemainingMinutes = -1
    if ($ttlConfigured -and $config.WallClockHours -gt 0) {
        $ttlRemainingMinutes = [int](($config.WallClockHours * 60) - $elapsed.TotalMinutes)
        if ($ttlRemainingMinutes -lt 0) { $ttlRemainingMinutes = 0 }
    }

    $status = if (-not $ttlConfigured) { 'Disabled' }
              elseif ($ttlExpired) { 'Expired' }
              else { 'Active' }

    return [pscustomobject]@{
        LabName              = $labName
        StartTime            = $startTime
        ElapsedHours         = $elapsedHours
        TTLConfigured        = $ttlConfigured
        TTLRemainingMinutes  = $ttlRemainingMinutes
        Action               = $config.Action
        Status               = $status
    }
}
```

Standard comment-based help (.SYNOPSIS, .DESCRIPTION, .OUTPUTS, .EXAMPLE) matching existing Public/ functions.

**Teardown integration — update Public/Reset-Lab.ps1:**

Add Unregister-LabTTLTask call during teardown. Insert between "Step 4: Prompt for confirmation" and "Step 5: Remove checkpoints first" (around line 138). Add:

```powershell
# Step 4.5: Unregister TTL monitoring task
Write-Host "Removing TTL monitoring task..." -ForegroundColor Cyan
try {
    $ttlResult = Unregister-LabTTLTask
    if ($ttlResult.TaskRemoved) {
        Write-Host "  Removed TTL monitoring task" -ForegroundColor Green
    }
}
catch {
    Write-Warning "TTL task cleanup failed: $($_.Exception.Message)"
}
```

This ensures no orphaned scheduled tasks remain after lab teardown. Unregister-LabTTLTask is already idempotent so this is safe even if no task exists.

**REFACTOR:** Verify all tests pass, verify Reset-Lab still functions correctly.
  </action>
  <verify>Run `pwsh -NoProfile -Command "Invoke-Pester Tests/LabUptime.Tests.ps1 -Output Detailed"` — all tests pass. Inspect Reset-Lab.ps1 to confirm Unregister-LabTTLTask call is present in teardown flow. Verify Get-LabUptime.ps1 has comment-based help.</verify>
  <done>Get-LabUptime returns structured PSCustomObject with uptime and TTL status. Reset-Lab calls Unregister-LabTTLTask during teardown. 10+ uptime tests passing. No orphaned tasks after teardown.</done>
</task>

</tasks>

<verification>
- [ ] Invoke-LabTTLMonitor checks both wall-clock and idle thresholds
- [ ] Monitor applies Save-VM or Stop-VM based on configured Action
- [ ] Monitor writes state to .planning/lab-ttl-state.json after each check
- [ ] Monitor returns audit PSCustomObject matching Invoke-LabQuickModeHeal pattern
- [ ] Get-LabUptime returns correct fields: LabName, StartTime, ElapsedHours, TTLConfigured, TTLRemainingMinutes, Action, Status
- [ ] Get-LabUptime returns empty array when no lab running
- [ ] Reset-Lab calls Unregister-LabTTLTask during teardown
- [ ] All Pester tests pass (monitor + uptime)
</verification>

<success_criteria>
Complete TTL monitoring pipeline: config read -> threshold check -> VM action -> state cache -> uptime query. Teardown cleans up scheduled tasks. All tests green. All 5 success criteria from the roadmap are achievable.
</success_criteria>

<output>
After completion, create `.planning/phases/26-lab-ttl-lifecycle-monitoring/26-03-SUMMARY.md`
</output>
