---
phase: 32-operational-workflows
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - Lab-Config.ps1
  - Private/Get-LabWorkflowConfig.ps1
  - Public/Save-LabWorkflow.ps1
  - Public/Get-LabWorkflow.ps1
  - Public/Invoke-LabWorkflow.ps1
  - Tests/LabWorkflow.Tests.ps1
autonomous: true
requirements:
  - OPS-02

must_haves:
  truths:
    - "Operator can create custom operation workflows (scripts that combine common actions)"
    - "Workflows are stored as JSON files in .planning/workflows/ directory"
    - "Each workflow has a name, description, and ordered list of steps"
    - "Workflow steps can reference bulk operations or individual VM operations"
    - "Invoke-LabWorkflow executes workflow steps in order with error handling"
    - "Get-LabWorkflow lists available workflows or retrieves single workflow details"
  artifacts:
    - path: "Lab-Config.ps1"
      provides: "Workflows configuration block with storage path"
      contains: "Workflows"
    - path: ".planning/workflows/"
      provides: "Workflow JSON file storage directory"
    - path: "Public/Save-LabWorkflow.ps1"
      provides: "Workflow creation API"
      exports: ["Save-LabWorkflow"]
      min_lines: 50
    - path: "Public/Get-LabWorkflow.ps1"
      provides: "Workflow listing and retrieval API"
      exports: ["Get-LabWorkflow"]
      min_lines: 60
    - path: "Public/Invoke-LabWorkflow.ps1"
      provides: "Workflow execution API"
      exports: ["Invoke-LabWorkflow"]
      min_lines: 80
    - path: "Tests/LabWorkflow.Tests.ps1"
      provides: "Unit tests for workflow CRUD and execution"
      min_lines: 60
  key_links:
    - from: "Invoke-LabWorkflow.ps1"
      to: "Invoke-LabBulkOperation.ps1"
      via: "Uses bulk operations for workflow steps"
      pattern: "Invoke-LabBulkOperation"
    - from: "Save-LabWorkflow.ps1"
      to: "Lab-Config.ps1"
      via: "Gets workflow storage path from config"
      pattern: "Get-LabWorkflowConfig"
    - from: ".planning/workflows/*.json"
      to: "Invoke-LabWorkflow.ps1"
      via: "Reads workflow definitions from JSON files"
      pattern: "ConvertFrom-Json"
---

<objective>
Create custom operation workflow infrastructure that enables operators to define reusable sequences of VM operations as JSON workflow files, supporting common multi-step scenarios like "start all domain controllers first, then member servers."

Purpose: Enable operators to automate common operational patterns by defining workflows as JSON files that can be saved, listed, and executed, reducing repetitive command sequences and ensuring consistent operational procedures.

Output: Workflow configuration in Lab-Config.ps1, Save-LabWorkflow/Get-LabWorkflow/Invoke-LabWorkflow public APIs, .planning/workflows/ storage directory, and unit tests for workflow management.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-operational-workflows/32-01-SUMMARY.md

# Existing patterns from codebase (for reference, not to copy)
Private/Get-LabScenarioTemplate.ps1 (Phase 14) - Shows JSON template loading pattern
Private/Get-LabCustomRole.ps1 (Phase 22) - Shows JSON file auto-discovery from .planning/
Public/Save-LabProfile.ps1 (Phase 18) - Shows save-to-JSON pattern
Public/Get-LabProfile.ps1 (Phase 18) - Shows list/detail retrieval pattern
</context>

<tasks>

<task type="auto">
  <name>Add Workflows configuration block to Lab-Config.ps1</name>
  <files>Lab-Config.ps1</files>
  <action>
Add the Workflows configuration block to Lab-Config.ps1 after the Analytics block (around line 260).

The configuration should follow the existing pattern:
```powershell
    Workflows = @{
        # Changing StoragePath moves where workflow definitions are stored.
        StoragePath = '.planning/workflows'
        # Changing Enabled toggles whether custom workflows can be executed.
        Enabled = $true
    }
```

This matches the pattern used for Analytics, TTL, STIG, ADMX, and Dashboard configuration blocks. Enabled defaults to true for workflows (operators want workflow capability by default). StoragePath uses .planning/workflows/ following the established directory pattern for JSON-based artifacts (scenarios, roles, profiles).
  </action>
  <verify>Test-Path variable:LabConfig.Workflows returns $true after dot-sourcing Lab-Config.ps1</verify>
  <done>Workflows block exists in Lab-Config.ps1 with StoragePath and Enabled keys</done>
</task>

<task type="auto">
  <name>Create Get-LabWorkflowConfig helper function</name>
  <files>Private/Get-LabWorkflowConfig.ps1</files>
  <action>
Create Private/Get-LabWorkflowConfig.ps1 following the exact pattern of Get-LabAnalyticsConfig:

```powershell
function Get-LabWorkflowConfig {
    <#
    .SYNOPSIS
        Reads workflow configuration from global lab config.

    .DESCRIPTION
        Get-LabWorkflowConfig returns a Workflows configuration object with safe
        defaults when keys are missing from $GlobalLabConfig. Contains ContainsKey
        guards for all nested keys to prevent errors under StrictMode.

    .OUTPUTS
        [pscustomobject] with StoragePath, Enabled properties.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param()

    $config = $GlobalLabConfig

    $storagePath = if ($config.ContainsKey('Workflows') -and $config.Workflows.ContainsKey('StoragePath')) {
        [string]$config.Workflows.StoragePath
    } else {
        '.planning/workflows'
    }

    $enabled = if ($config.ContainsKey('Workflows') -and $config.Workflows.ContainsKey('Enabled')) {
        [bool]$config.Workflows.Enabled
    } else {
        $true
    }

    return [pscustomobject]@{
        StoragePath = $storagePath
        Enabled     = $enabled
    }
}
```

This function follows the established pattern from Phase 30 (Get-LabAnalyticsConfig). It provides ContainsKey guards for safe config access under StrictMode, returns type-casted values with safe defaults, and exports a PSCustomObject with all configuration fields.
  </action>
  <verify>Get-LabWorkflowConfig returns PSCustomObject with StoragePath='.planning/workflows', Enabled=$true when Workflows block missing from $GlobalLabConfig</verify>
  <done>Get-LabWorkflowConfig helper exists and follows established config helper pattern</done>
</task>

<task type="auto">
  <name>Create Save-LabWorkflow function</name>
  <files>Public/Save-LabWorkflow.ps1</files>
  <action>
Create Public/Save-LabWorkflow.ps1 for saving workflow definitions:

```powershell
function Save-LabWorkflow {
    <#
    .SYNOPSIS
        Saves a custom operational workflow to a JSON file.

    .DESCRIPTION
        Save-LabWorkflow creates a workflow definition file that specifies a
        sequence of VM operations. Workflows can include bulk operations,
        individual VM operations, and delays between steps. Useful for
        automating common multi-step procedures.

    .PARAMETER Name
        Name of the workflow (filename without .json extension).

    .PARAMETER Description
        Human-readable description of what the workflow does.

    .PARAMETER Steps
        Array of workflow steps. Each step is a hashtable with Operation,
        VMName (optional), CheckpointName (for checkpoint operations), and
        DelaySeconds (optional) properties.

    .PARAMETER Force
        Overwrite existing workflow file if it exists.

    .EXAMPLE
        Save-LabWorkflow -Name 'StartLab' -Description 'Start all lab VMs in order' -Steps @(
            @{ Operation = 'Start'; VMName = @('dc1') },
            @{ Operation = 'Start'; VMName = @('svr1', 'cli1'); DelaySeconds = 30 }
        )
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [string]$Name,

        [string]$Description,

        [Parameter(Mandatory)]
        [hashtable[]]$Steps,

        [switch]$Force
    )

    $workflowConfig = Get-LabWorkflowConfig

    if (-not $workflowConfig.Enabled) {
        throw 'Workflows are disabled in Lab configuration'
    }

    $storagePath = $workflowConfig.StoragePath
    $parentDir = Split-Path -Parent $storagePath

    if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir)) {
        $null = New-Item -Path $parentDir -ItemType Directory -Force
        Write-Verbose "Created directory: $parentDir"
    }

    if (-not (Test-Path $storagePath)) {
        $null = New-Item -Path $storagePath -ItemType Directory -Force
        Write-Verbose "Created directory: $storagePath"
    }

    $fileName = if ($Name -match '\.json$') { $Name } else { "$Name.json" }
    $filePath = Join-Path (Join-Path (Split-Path -Parent $PSScriptRoot) $storagePath) $fileName

    if ((Test-Path $filePath) -and -not $Force) {
        throw "Workflow file already exists: $filePath (use -Force to overwrite)"
    }

    $workflow = [ordered]@{
        Name        = $Name
        Description = $Description
        Version     = '1.0'
        CreatedAt   = (Get-Date -Format 'o')
        Steps       = @()
    }

    foreach ($step in $Steps) {
        $stepObj = [ordered]@{
            Operation = $step.Operation
        }

        if ($step.ContainsKey('VMName')) {
            $stepObj.VMName = @($step.VMName)
        }

        if ($step.ContainsKey('CheckpointName')) {
            $stepObj.CheckpointName = $step.CheckpointName
        }

        if ($step.ContainsKey('DelaySeconds')) {
            $stepObj.DelaySeconds = [int]$step.DelaySeconds
        }

        $workflow.Steps += $stepObj
    }

    $targetPath = $filePath
    if ($PSCmdlet.ShouldProcess($targetPath, 'Save workflow')) {
        $workflow | ConvertTo-Json -Depth 4 | Set-Content -Path $filePath -Encoding UTF8
        Write-Verbose "Saved workflow: $filePath"

        return [pscustomobject]@{
            Name   = $Name
            Path   = $filePath
            Status = 'Created'
        }
    }
}
```

This function follows the save-to-JSON pattern from Save-LabProfile (Phase 18). It creates the workflows directory if needed, validates the Force parameter for overwrite protection, and builds an ordered workflow object with proper structure. Each step is processed to ensure VMName arrays are properly formatted and optional fields are included only when specified.
  </action>
  <verify>Save-LabWorkflow -Name 'TestWorkflow' -Description 'Test' -Steps @{ Operation = 'Start'; VMName = @('vm1') } creates .planning/workflows/TestWorkflow.json</verify>
  <done>Save-LabWorkflow function exists and creates workflow JSON files correctly</done>
</task>

<task type="auto">
  <name>Create Get-LabWorkflow function</name>
  <files>Public/Get-LabWorkflow.ps1</files>
  <action>
Create Public/Get-LabWorkflow.ps1 for listing and retrieving workflows:

```powershell
function Get-LabWorkflow {
    <#
    .SYNOPSIS
        Retrieves custom workflow definitions.

    .DESCRIPTION
        Get-LabWorkflow lists all available workflows or retrieves details for
        a specific workflow. Workflows are stored as JSON files in the
        .planning/workflows/ directory and define sequences of VM operations.

    .PARAMETER Name
        Name of the workflow to retrieve. If not specified, lists all workflows.

    .EXAMPLE
        Get-LabWorkflow
        Lists all available workflows.

    .EXAMPLE
        Get-LabWorkflow -Name 'StartLab'
        Retrieves details for the StartLab workflow.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [string]$Name
    )

    $workflowConfig = Get-LabWorkflowConfig
    $storagePath = Join-Path (Split-Path -Parent $PSScriptRoot) $workflowConfig.StoragePath

    if (-not (Test-Path $storagePath)) {
        return @()
    }

    if ($PSBoundParameters.ContainsKey('Name')) {
        $fileName = if ($Name -match '\.json$') { $Name } else { "$Name.json" }
        $filePath = Join-Path $storagePath $fileName

        if (-not (Test-Path $filePath)) {
            Write-Warning "Workflow not found: $Name"
            return @()
        }

        try {
            $workflow = Get-Content -Raw -Path $filePath | ConvertFrom-Json
            return [pscustomobject]@{
                Name        = $workflow.Name
                Description = $workflow.Description
                Version     = $workflow.Version
                CreatedAt   = $workflow.CreatedAt
                StepCount   = $workflow.Steps.Count
                Steps       = @($workflow.Steps)
                Path        = $filePath
            }
        }
        catch {
            Write-Warning "Failed to read workflow file '$filePath': $($_.Exception.Message)"
            return @()
        }
    }
    else {
        $workflows = @()

        Get-ChildItem -Path $storagePath -Filter '*.json' -ErrorAction SilentlyContinue | ForEach-Object {
            try {
                $workflow = Get-Content -Raw -Path $_.FullName | ConvertFrom-Json

                $workflows += [pscustomobject]@{
                    Name        = $workflow.Name
                    Description = $workflow.Description
                    Version     = $workflow.Version
                    CreatedAt   = $workflow.CreatedAt
                    StepCount   = $workflow.Steps.Count
                    Path        = $_.FullName
                }
            }
            catch {
                Write-Warning "Failed to read workflow file '$($_.FullName)': $($_.Exception.Message)"
            }
        }

        return @($workflows | Sort-Object -Property Name)
    }
}
```

This function follows the list/detail retrieval pattern from Get-LabProfile (Phase 18) and Get-LabCustomRole (Phase 22). In list mode (no Name parameter), it returns all workflows with summary information. In detail mode (Name specified), it returns the full workflow including the Steps array. Corrupt files emit warnings but don't crash the listing.
  </action>
  <verify>Get-LabWorkflow returns array of workflow objects with Name, Description, StepCount properties</verify>
  <done>Get-LabWorkflow function exists with list and detail modes</done>
</task>

<task type="auto">
  <name>Create Invoke-LabWorkflow function</name>
  <files>Public/Invoke-LabWorkflow.ps1</files>
  <action>
Create Public/Invoke-LabWorkflow.ps1 for executing workflows:

```powershell
function Invoke-LabWorkflow {
    <#
    .SYNOPSIS
        Executes a custom operational workflow.

    .DESCRIPTION
        Invoke-LabWorkflow runs a predefined workflow, executing each step
        in sequence with error handling. Workflows can start, stop, suspend,
        or checkpoint VMs with optional delays between steps. Failed steps
        are logged but don't stop workflow execution unless -StopOnError.

    .PARAMETER Name
        Name of the workflow to execute.

    .PARAMETER StopOnError
        Stop workflow execution if any step fails.

    .PARAMETER WhatIf
        Shows what would happen without executing.

    .EXAMPLE
        Invoke-LabWorkflow -Name 'StartLab'
        Executes the StartLab workflow.
    #>
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory)]
        [string]$Name,

        [switch]$StopOnError
    )

    $workflowConfig = Get-LabWorkflowConfig

    if (-not $workflowConfig.Enabled) {
        throw 'Workflows are disabled in Lab configuration'
    }

    $workflow = Get-LabWorkflow -Name $Name

    if (-not $workflow) {
        throw "Workflow not found: $Name"
    }

    $targetSteps = $workflow.Steps.Count
    if (-not $PSCmdlet.ShouldProcess($Name, "Execute $targetSteps workflow steps")) {
        return
    }

    Write-Verbose "Invoke-LabWorkflow: Executing workflow '$Name' ($($workflow.StepCount) steps)"

    $results = [System.Collections.Generic.List[pscustomobject]]::new()
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    foreach ($step in $workflow.Steps) {
        $stepNum = $results.Count + 1

        Write-Verbose "Invoke-LabWorkflow: Step $stepNum/$($workflow.StepCount) - $($step.Operation)"

        $stepResult = [ordered]@{
            StepNumber = $stepNum
            Operation  = $step.Operation
            Status     = 'Pending'
            VMName     = if ($step.VMName) { @($step.VMName) } else { @() }
            Error      = $null
        }

        try {
            $operationParams = @{
                Operation = $step.Operation
            }

            if ($step.VMName -and $step.VMName.Count -gt 0) {
                $operationParams.VMName = @($step.VMName)
            }

            if ($step.CheckpointName) {
                $operationParams.CheckpointName = $step.CheckpointName
            }

            $result = Invoke-LabBulkOperation @operationParams

            $stepResult.Status = $result.OverallStatus
            $stepResult.SuccessCount = $result.Success.Count
            $stepResult.FailedCount = $result.Failed.Count
            $stepResult.SkippedCount = $result.Skipped.Count

            if ($result.OverallStatus -eq 'Failed' -and $StopOnError) {
                $stepResult.Error = 'Operation failed and StopOnError specified'
                $results.Add([pscustomobject]$stepResult)
                throw "Workflow stopped at step $stepNum due to failure"
            }
        }
        catch {
            $stepResult.Status = 'Error'
            $stepResult.Error = $_.Exception.Message

            if ($StopOnError) {
                $results.Add([pscustomobject]$stepResult)
                throw
            }
        }

        $results.Add([pscustomobject]$stepResult)

        if ($step.DelaySeconds -gt 0) {
            Write-Verbose "Invoke-LabWorkflow: Delaying $($step.DelaySeconds) seconds before next step"
            Start-Sleep -Seconds $step.DelaySeconds
        }
    }

    $stopwatch.Stop()

    $failedSteps = @($results | Where-Object { $_.Status -eq 'Error' -or $_.Status -eq 'Failed' })
    $overallStatus = switch ($failedSteps.Count) {
        { $_ -eq 0 } { 'Completed' }
        { $_ -lt $results.Count } { 'Partial' }
        default { 'Failed' }
    }

    return [pscustomobject]@{
        WorkflowName  = $Name
        OverallStatus = $overallStatus
        TotalSteps    = $workflow.StepCount
        CompletedSteps = $results.Count
        FailedSteps   = $failedSteps.Count
        Results       = @($results)
        Duration      = $stopwatch.Elapsed
    }
}
```

This function executes workflow steps in sequence, using Invoke-LabBulkOperation for each step. It supports StopOnError for strict workflow execution where any failure halts the workflow. Delays between steps are honored for scenarios where dependent operations need time to complete. The result structure provides detailed per-step feedback for operational visibility.
  </action>
  <verify>Invoke-LabWorkflow -Name 'TestWorkflow' executes workflow steps and returns result object with OverallStatus and Results array</verify>
  <done>Invoke-LabWorkflow function exists and executes workflows with error handling</done>
</task>

<task type="auto">
  <name>Create unit tests for workflow management</name>
  <files>Tests/LabWorkflow.Tests.ps1</files>
  <action>
Create Tests/LabWorkflow.Tests.ps1 with unit tests:

```powershell
Describe 'Lab Workflow Management' {
    BeforeAll {
        $moduleRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
        Import-Module "$moduleRoot\SimpleLab\SimpleLab.psd1" -Force

        . "$moduleRoot\Private\Get-LabWorkflowConfig.ps1"
        . "$moduleRoot\Public\Save-LabWorkflow.ps1"
        . "$moduleRoot\Public\Get-LabWorkflow.ps1"

        $testWorkflowPath = Join-Path $moduleRoot '.planning\workflows'

        function New-TestWorkflow {
            param([string]$Name, [hashtable[]]$Steps)
            Save-LabWorkflow -Name $Name -Description "Test workflow $Name" -Steps $Steps -Force
        }

        function Remove-TestWorkflow {
            param([string]$Name)
            $filePath = Join-Path $testWorkflowPath "$Name.json"
            if (Test-Path $filePath) {
                Remove-Item -Path $filePath -Force
            }
        }
    }

    BeforeEach {
        if (-not (Test-Path $testWorkflowPath)) {
            New-Item -Path $testWorkflowPath -ItemType Directory -Force | Out-Null
        }
    }

    AfterEach {
        Get-ChildItem -Path $testWorkflowPath -Filter 'test-*.json' -ErrorAction SilentlyContinue | Remove-Item -Force
    }

    Context 'Save-LabWorkflow' {
        It 'Creates workflow JSON file' {
            $steps = @(
                @{ Operation = 'Start'; VMName = @('dc1') }
            )

            $result = Save-LabWorkflow -Name 'test-workflow' -Description 'Test' -Steps $steps -Force

            $result.Status | Should -Be 'Created'
            $result.Path | Should -Exist
        }

        It 'Stores workflow steps correctly' {
            $steps = @(
                @{ Operation = 'Start'; VMName = @('dc1', 'svr1'); DelaySeconds = 10 },
                @{ Operation = 'Stop'; VMName = @('cli1') }
            )

            Save-LabWorkflow -Name 'test-steps' -Steps $steps -Force

            $workflow = Get-LabWorkflow -Name 'test-steps'
            $workflow.StepCount | Should -Be 2
            $workflow.Steps[0].Operation | Should -Be 'Start'
            $workflow.Steps[0].VMName.Count | Should -Be 2
            $workflow.Steps[0].DelaySeconds | Should -Be 10
        }

        It 'Rejects duplicate names without Force' {
            $steps = @{ Operation = 'Start'; VMName = @('vm1') }

            Save-LabWorkflow -Name 'test-dup' -Steps $steps -Force
            { Save-LabWorkflow -Name 'test-dup' -Steps $steps } | Should -Throw
        }
    }

    Context 'Get-LabWorkflow' {
        It 'Lists all workflows when Name not specified' {
            New-TestWorkflow -Name 'test-a' -Steps @{ Operation = 'Start'; VMName = @() }
            New-TestWorkflow -Name 'test-b' -Steps @{ Operation = 'Stop'; VMName = @() }

            $workflows = Get-LabWorkflow
            $workflows.Count | Should -BeGreaterOrEqual 2
        }

        It 'Retrieves specific workflow by Name' {
            New-TestWorkflow -Name 'test-specific' -Steps @{ Operation = 'Start'; VMName = @('dc1') }

            $workflow = Get-LabWorkflow -Name 'test-specific'
            $workflow.Name | Should -Be 'test-specific'
            $workflow.StepCount | Should -Be 1
        }

        It 'Returns empty for missing workflow' {
            $workflow = Get-LabWorkflow -Name 'nonexistent'
            $workflow | Should -BeNullOrEmpty
        }
    }
}
```

These tests verify the workflow CRUD functionality. Tests cover workflow creation, step storage, duplicate detection, listing, and retrieval. The test pattern follows Pester 5 conventions with BeforeAll/BeforeEach/AfterEach for proper setup and cleanup. The New-TestWorkflow and Remove-TestWorkflow helpers provide clean test isolation.
  </action>
  <verify>Invoke-Pester Tests/LabWorkflow.Tests.ps1 -PassThru | Select-Object -ExpandProperty PassedCount is greater than 0</verify>
  <done>Unit tests exist and verify workflow management correctness</done>
</task>

<task type="auto">
  <name>Add workflow functions to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export the workflow functions.

In SimpleLab.psm1, add 'Save-LabWorkflow', 'Get-LabWorkflow', 'Invoke-LabWorkflow' to the Export-ModuleMember array.
In SimpleLab.psd1, add 'Save-LabWorkflow', 'Get-LabWorkflow', 'Invoke-LabWorkflow' to the FunctionsToExport array.

This follows the established pattern for public API functions and makes the workflow functionality available to operators.
  </action>
  <verify>Get-Command Save-LabWorkflow, Get-LabWorkflow, Invoke-LabWorkflow -Module SimpleLab returns command info for all three</verify>
  <done>Workflow functions are exported from the SimpleLab module</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test config: Get-LabWorkflowConfig returns object with StoragePath='.planning/workflows', Enabled=$true
3. Test save: Save-LabWorkflow creates workflow JSON file in .planning/workflows/
4. Test list: Get-LabWorkflow returns all workflows
5. Test detail: Get-LabWorkflow -Name 'X' returns workflow with Steps array
6. Test execute: Invoke-LabWorkflow executes workflow steps
7. Run tests: Pester tests for workflows pass
</verification>

<success_criteria>
1. Workflows configuration block exists in Lab-Config.ps1
2. Save-LabWorkflow creates workflow JSON files with step definitions
3. Get-LabWorkflow lists all workflows or retrieves specific workflow details
4. Invoke-LabWorkflow executes workflow steps in sequence
5. Workflows support delays between steps for dependent operations
6. StopOnError parameter halts workflow on step failure when specified
7. Unit tests verify workflow CRUD and execution
8. Workflow functions are exported from SimpleLab module
</success_criteria>

<output>
After completion, create `.planning/phases/32-operational-workflows/32-02-SUMMARY.md` with:
- Actual files created with line counts
- Workflow JSON schema documentation
- Test coverage summary
- Any deviations from plan
- Next steps for Plan 32-03
</output>
