---
phase: 32-operational-workflows
plan: 04
type: execute
wave: 4
depends_on: ["32-01", "32-02", "32-03"]
files_modified:
  - Private/Write-LabOperationSummary.ps1
  - Public/Invoke-LabBulkOperation.ps1
  - Public/Invoke-LabWorkflow.ps1
  - Tests/LabOperationSummary.Tests.ps1
autonomous: true
requirements:
  - OPS-04

must_haves:
  truths:
    - "Operator receives confirmation summary after bulk operations complete"
    - "Confirmation summary includes operation type, VM counts, and duration"
    - "Summary shows Success/Failed/Skipped VM lists with error details"
    - "Summaries are written to run history log for audit trail"
    - "Summary formatting supports console output and JSON export"
    - "Workflow execution includes per-step confirmation details"
  artifacts:
    - path: "Private/Write-LabOperationSummary.ps1"
      provides: "Summary writing and formatting function"
      min_lines: 80
    - path: "Public/Invoke-LabBulkOperation.ps1"
      provides: "Updated with summary integration"
      contains: "Write-LabOperationSummary"
    - path: "Public/Invoke-LabWorkflow.ps1"
      provides: "Updated with workflow summary integration"
      contains: "Write-LabOperationSummary"
    - path: "Tests/LabOperationSummary.Tests.ps1"
      provides: "Unit tests for summary formatting and output"
      min_lines: 50
  key_links:
    - from: "Invoke-LabBulkOperation.ps1"
      to: "Write-LabOperationSummary.ps1"
      via: "Calls summary writer after operations complete"
      pattern: "Write-LabOperationSummary"
    - from: "Write-LabOperationSummary.ps1"
      to: "Write-LabRunArtifacts.ps1"
      via: "Writes summary to run history log"
      pattern: "Write-LabRunArtifacts"
    - from: "Invoke-LabWorkflow.ps1"
      to: "Write-LabOperationSummary.ps1"
      via: "Calls summary writer with workflow results"
      pattern: "Write-LabOperationSummary"
---

<objective>
Create confirmation summary infrastructure that provides detailed operation completion feedback including success/failure/skipped counts, error details, duration, and audit trail logging.

Purpose: Give operators clear visibility into bulk operation results with formatted summaries showing what succeeded, what failed, and why, including per-step details for workflow executions and persistent logging for audit trails.

Output: Write-LabOperationSummary summary writer, integration with Invoke-LabBulkOperation and Invoke-LabWorkflow, and unit tests covering summary formatting and output.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-operational-workflows/32-01-SUMMARY.md
@.planning/phases/32-operational-workflows/32-02-SUMMARY.md
@.planning/phases/32-operational-workflows/32-03-SUMMARY.md

# Existing patterns from codebase (for reference, not to copy)
Private/Write-LabRunArtifacts.ps1 - Shows run history logging pattern
Private/Write-LabAnalyticsEvent.ps1 (Phase 30) - Shows event logging with structured data
Public/Get-LabRunHistory.ps1 (Phase 19) - Shows run artifact structure
</context>

<tasks>

<task type="auto">
  <name>Create Write-LabOperationSummary function</name>
  <files>Private/Write-LabOperationSummary.ps1</files>
  <action>
Create Private/Write-LabOperationSummary.ps1 with summary writing logic:

```powershell
function Write-LabOperationSummary {
    <#
    .SYNOPSIS
        Writes confirmation summary for bulk operations.

    .DESCRIPTION
        Write-LabOperationSummary formats and displays operation completion
        summaries including success/failure/skipped counts, error details,
        duration, and per-step breakdown for workflows. Optionally writes
        summary to run history log for audit trail.

    .PARAMETER Operation
        Operation type that was performed.

    .PARAMETER Result
        Result object from Invoke-LabBulkOperation or Invoke-LabWorkflow.

    .PARAMETER WorkflowMode
        Indicates the result is from a workflow execution (switch).

    .PARAMETER LogToHistory
        Write summary to run history log (switch).

    .OUTPUTS
        [pscustomobject] with formatted summary text, stats, and log path.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string]$Operation,

        [Parameter(Mandatory)]
        [pscustomobject]$Result,

        [switch]$WorkflowMode,

        [switch]$LogToHistory
    )

    $summaryLines = [System.Collections.Generic.List[string]]::new()
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'

    # Header
    $summaryLines.Add("=" * 60)
    $summaryLines.Add("Operation Summary: $Operation")
    $summaryLines.Add("Completed: $timestamp")
    $summaryLines.Add("=" * 60)
    $summaryLines.Add("")

    # Overall status
    $statusColor = switch ($Result.OverallStatus) {
        'OK' { 'Green' }
        'Completed' { 'Green' }
        'Partial' { 'Yellow' }
        'Warning' { 'Yellow' }
        'Failed' { 'Red' }
        'Fail' { 'Red' }
        default { 'Gray' }
    }

    $summaryLines.Add("Overall Status: $($Result.OverallStatus)")

    if ($WorkflowMode) {
        $summaryLines.Add("Workflow: $($Result.WorkflowName)")
        $summaryLines.Add("Steps Completed: $($Result.CompletedSteps) / $($Result.TotalSteps)")
        $summaryLines.Add("Failed Steps: $($Result.FailedSteps)")
        $summaryLines.Add("Duration: $($Result.Duration.ToString('mm\:ss\.fff'))")
    }
    else {
        $summaryLines.Add("Operation Count: $($Result.OperationCount)")
        $summaryLines.Add("Duration: $($Result.Duration.ToString('mm\:ss\.fff'))")
        $summaryLines.Add("Parallel: $($Result.Parallel)")
    }

    $summaryLines.Add("")

    # Success/Failed/Skipped breakdown
    if ($WorkflowMode) {
        $summaryLines.Add("-" * 40)
        $summaryLines.Add("Step Results:")
        $summaryLines.Add("")

        foreach ($stepResult in $Result.Results) {
            $stepStatus = switch ($stepResult.Status) {
                'Completed' { '✓' }
                'OK' { '✓' }
                'Partial' { '⚠' }
                'Warning' { '⚠' }
                'Failed' { '✗' }
                'Error' { '✗' }
                default { '?' }
            }

            $summaryLines.Add("  Step $($stepResult.StepNumber): $stepStatus $($stepResult.Operation)")

            if ($stepResult.VMName -and $stepResult.VMName.Count -gt 0) {
                $summaryLines.Add("    VMs: $($stepResult.VMName -join ', ')")
            }

            if ($stepResult.Error) {
                $summaryLines.Add("    Error: $($stepResult.Error)")
            }

            if ($stepResult.Status -eq 'Partial' -or $stepResult.Status -eq 'Warning') {
                $summaryLines.Add("    Success: $($stepResult.SuccessCount), Failed: $($stepResult.FailedCount), Skipped: $($stepResult.SkippedCount)")
            }

            $summaryLines.Add("")
        }
    }
    else {
        $summaryLines.Add("-" * 40)
        $summaryLines.Add("Results Breakdown:")
        $summaryLines.Add("")

        $summaryLines.Add("  Success: $($Result.Success.Count) VM(s)")
        if ($Result.Success.Count -gt 0) {
            $summaryLines.Add("    $($Result.Success -join ', ')")
        }
        $summaryLines.Add("")

        $summaryLines.Add("  Failed: $($Result.Failed.Count) VM(s)")
        if ($Result.Failed.Count -gt 0) {
            foreach ($failure in $Result.Failed) {
                $summaryLines.Add("    - $($failure.VMName): $($failure.Error)")
            }
        }
        else {
            $summaryLines.Add("    None")
        }
        $summaryLines.Add("")

        $summaryLines.Add("  Skipped: $($Result.Skipped.Count) VM(s)")
        if ($Result.Skipped.Count -gt 0) {
            foreach ($skip in $Result.Skipped) {
                $summaryLines.Add("    - $skip")
            }
        }
        else {
            $summaryLines.Add("    None")
        }
        $summaryLines.Add("")
    }

    # Footer
    $summaryLines.Add("=" * 60)

    # Format for console output
    $consoleOutput = $summaryLines -join "`n"

    # Log to history if requested
    $logPath = $null
    if ($LogToHistory) {
        try {
            $logEntry = [ordered]@{
                Timestamp      = $timestamp
                Operation      = $Operation
                OverallStatus  = $Result.OverallStatus
                SummaryType    = if ($WorkflowMode) { 'Workflow' } else { 'BulkOperation' }
                Result         = $Result
            }

            # Use existing run artifacts infrastructure
            $runId = if ($Result.WorkflowName) {
                "$($Result.WorkflowName)-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
            } else {
                "$($Operation)-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
            }

            # Write to run logs directory
            $runData = [ordered]@{
                Timestamp      = $timestamp
                Action         = if ($WorkflowMode) { 'Workflow' } else { 'BulkOperation' }
                Operation      = $Operation
                Result         = $Result.OverallStatus
                Duration       = if ($Result.Duration) { $Result.Duration.ToString() } else { $null }
                SuccessCount   = if ($Result.Success) { $Result.Success.Count } elseif ($Result.CompletedSteps) { $Result.CompletedSteps } else { 0 }
                FailedCount    = if ($Result.Failed) { $Result.Failed.Count } elseif ($Result.FailedSteps) { $Result.FailedSteps } else { 0 }
                Summary        = $consoleOutput
            }

            $runLogsDir = Join-Path (Split-Path -Parent $PSScriptRoot) '.planning\run-logs'
            $null = New-Item -Path $runLogsDir -ItemType Directory -Force -ErrorAction SilentlyContinue

            $logFileName = "$runId-summary.json"
            $logFilePath = Join-Path $runLogsDir $logFileName

            $runData | ConvertTo-Json -Depth 4 | Set-Content -Path $logFilePath -Encoding UTF8
            $logPath = $logFilePath

            Write-Verbose "Write-LabOperationSummary: Logged summary to $logFilePath"
        }
        catch {
            Write-Warning "Failed to log operation summary: $($_.Exception.Message)"
        }
    }

    return [pscustomobject]@{
        FormattedSummary = $consoleOutput
        Timestamp       = $timestamp
        Operation       = $Operation
        OverallStatus   = $Result.OverallStatus
        LogPath         = $logPath
    }
}
```

This function creates formatted summaries for both bulk operations and workflow executions. It builds a structured summary with header, overall status, detailed results breakdown, and footer. For workflows, it includes per-step details with status indicators. The LogToHistory parameter integrates with the existing run history infrastructure to create audit trail entries. The return object provides the formatted text, metadata, and log file path.
  </action>
  <verify>Write-LabOperationSummary -Operation 'Start' -Result $testResult returns object with FormattedSummary property containing multi-line text</verify>
  <done>Write-LabOperationSummary function exists and formats operation summaries</done>
</task>

<task type="auto">
  <name>Integrate summary with Invoke-LabBulkOperation</name>
  <files>Public/Invoke-LabBulkOperation.ps1</files>
  <action>
Modify Public/Invoke-LabBulkOperation.ps1 to automatically generate summaries after operations complete.

Add the following after line 112 (after the return $result statement, but modify to capture and add summary):

Replace the final return statement with:

```powershell
    # Generate summary for operator feedback
    $summary = Write-LabOperationSummary -Operation $result.Operation -Result $result

    # Display summary if not in quiet mode
    if (-not $PSBoundParameters.ContainsKey('ErrorAction') -or $ErrorActionPreference -ne 'SilentlyContinue') {
        Write-Host $summary.FormattedSummary
    }

    return [pscustomobject]@{
        Success       = $result.Success
        Failed        = $result.Failed
        Skipped       = $result.Skipped
        OverallStatus = $result.OverallStatus
        Operation     = $result.Operation
        OperationCount = $result.OperationCount
        Duration      = $result.Duration
        Parallel      = $result.Parallel
        Summary       = $summary
    }
```

This modification captures the result, generates a formatted summary, displays it to the operator (unless in silent mode), and returns an augmented result object that includes the Summary property. The summary provides immediate feedback on what succeeded, failed, or was skipped with clear formatting.
  </action>
  <verify>Invoke-LabBulkOperation -VMName @('testvm') -Operation Start returns result object with Summary property containing FormattedSummary</verify>
  <done>Invoke-LabBulkOperation automatically generates and displays operation summaries</done>
</task>

<task type="auto">
  <name>Integrate summary with Invoke-LabWorkflow</name>
  <files>Public/Invoke-LabWorkflow.ps1</files>
  <action>
Modify Public/Invoke-LabWorkflow.ps1 to automatically generate summaries after workflow execution.

Replace the final return statement (around line 97) with:

```powershell
    # Generate summary for workflow execution
    $summary = Write-LabOperationSummary -Operation $Name -Result $result -WorkflowMode -LogToHistory

    # Display summary
    Write-Host $summary.FormattedSummary

    return [pscustomobject]@{
        WorkflowName   = $result.WorkflowName
        OverallStatus  = $result.OverallStatus
        TotalSteps     = $result.TotalSteps
        CompletedSteps = $result.CompletedSteps
        FailedSteps    = $result.FailedSteps
        Results        = $result.Results
        Duration       = $result.Duration
        Summary        = $summary
    }
```

This modification generates a workflow-mode summary (which includes per-step breakdown), logs it to history for audit trail, displays it to the operator, and returns an augmented result object with the Summary property. The workflow summary provides detailed feedback on each step execution.
  </action>
  <verify>Invoke-LabWorkflow -Name 'TestWorkflow' returns result object with Summary property containing FormattedSummary with step-by-step details</verify>
  <done>Invoke-LabWorkflow automatically generates and displays workflow execution summaries</done>
</task>

<task type="auto">
  <name>Create unit tests for summary functionality</name>
  <files>Tests/LabOperationSummary.Tests.ps1</files>
  <action>
Create Tests/LabOperationSummary.Tests.ps1 with unit tests:

```powershell
Describe 'Write-LabOperationSummary' {
    BeforeAll {
        $moduleRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
        Import-Module "$moduleRoot\SimpleLab\SimpleLab.psd1" -Force

        . "$moduleRoot\Private\Write-LabOperationSummary.ps1"
    }

    Context 'Bulk operation summary formatting' {
        It 'Formats summary for successful bulk operation' {
            $result = [pscustomobject]@{
                OverallStatus = 'OK'
                Operation = 'Start'
                OperationCount = 3
                Duration = [TimeSpan]::Parse('00:00:05.234')
                Success = @('vm1', 'vm2', 'vm3')
                Failed = @()
                Skipped = @()
                Parallel = $false
            }

            $summary = Write-LabOperationSummary -Operation 'Start' -Result $result

            $summary.FormattedSummary | Should -Match 'Operation Summary: Start'
            $summary.FormattedSummary | Should -Match 'Overall Status: OK'
            $summary.FormattedSummary | Should -Match 'Success: 3 VM\(s\)'
            $summary.FormattedSummary | Should -Match 'vm1.*vm2.*vm3'
        }

        It 'Formats summary with failed operations' {
            $result = [pscustomobject]@{
                OverallStatus = 'Partial'
                Operation = 'Stop'
                OperationCount = 3
                Duration = [TimeSpan]::Parse('00:00:03.123')
                Success = @('vm1')
                Failed = @([pscustomobject]@{ VMName = 'vm2'; Error = 'VM not responding' })
                Skipped = @('vm3 (already off)')
                Parallel = $false
            }

            $summary = Write-LabOperationSummary -Operation 'Stop' -Result $result

            $summary.FormattedSummary | Should -Match 'Overall Status: Partial'
            $summary.FormattedSummary | Should -Match 'Success: 1 VM\(s\)'
            $summary.FormattedSummary | Should -Match 'Failed: 1 VM\(s\)'
            $summary.FormattedSummary | Should -Match 'vm2: VM not responding'
            $summary.FormattedSummary | Should -Match 'Skipped: 1 VM\(s\)'
        }

        It 'Formats duration correctly' {
            $result = [pscustomobject]@{
                OverallStatus = 'OK'
                Operation = 'Start'
                OperationCount = 1
                Duration = [TimeSpan]::Parse('00:01:23.456')
                Success = @('vm1')
                Failed = @()
                Skipped = @()
                Parallel = $false
            }

            $summary = Write-LabOperationSummary -Operation 'Start' -Result $result

            $summary.FormattedSummary | Should -Match 'Duration: 01\:23\.456'
        }
    }

    Context 'Workflow summary formatting' {
        It 'Formats summary for workflow execution' {
            $result = [pscustomobject]@{
                WorkflowName = 'TestWorkflow'
                OverallStatus = 'Completed'
                TotalSteps = 2
                CompletedSteps = 2
                FailedSteps = 0
                Duration = [TimeSpan]::Parse('00:00:10.500')
                Results = @(
                    [pscustomobject]@{
                        StepNumber = 1
                        Operation = 'Start'
                        Status = 'OK'
                        VMName = @('dc1')
                        SuccessCount = 1
                        FailedCount = 0
                        SkippedCount = 0
                        Error = $null
                    },
                    [pscustomobject]@{
                        StepNumber = 2
                        Operation = 'Start'
                        Status = 'OK'
                        VMName = @('svr1')
                        SuccessCount = 1
                        FailedCount = 0
                        SkippedCount = 0
                        Error = $null
                    }
                )
            }

            $summary = Write-LabOperationSummary -Operation 'TestWorkflow' -Result $result -WorkflowMode

            $summary.FormattedSummary | Should -Match 'Workflow: TestWorkflow'
            $summary.FormattedSummary | Should -Match 'Steps Completed: 2 / 2'
            $summary.FormattedSummary | Should -Match 'Step 1: .* Start'
            $summary.FormattedSummary | Should -Match 'Step 2: .* Start'
        }

        It 'Formats summary with failed workflow steps' {
            $result = [pscustomobject]@{
                WorkflowName = 'FailingWorkflow'
                OverallStatus = 'Partial'
                TotalSteps = 2
                CompletedSteps = 2
                FailedSteps = 1
                Duration = [TimeSpan]::Parse('00:00:05.000')
                Results = @(
                    [pscustomobject]@{
                        StepNumber = 1
                        Operation = 'Start'
                        Status = 'OK'
                        VMName = @('dc1')
                    },
                    [pscustomobject]@{
                        StepNumber = 2
                        Operation = 'Start'
                        Status = 'Failed'
                        VMName = @('svr1')
                        Error = 'VM not found'
                    }
                )
            }

            $summary = Write-LabOperationSummary -Operation 'FailingWorkflow' -Result $result -WorkflowMode

            $summary.FormattedSummary | Should -Match 'Failed Steps: 1'
            $summary.FormattedSummary | Should -Match 'Step 2: .* Start'
            $summary.FormattedSummary | Should -Match 'Error: VM not found'
        }
    }

    Context 'Summary object properties' {
        It 'Returns summary object with all required properties' {
            $result = [pscustomobject]@{
                OverallStatus = 'OK'
                Operation = 'Start'
                OperationCount = 1
                Duration = [TimeSpan]::Parse('00:00:01.000')
                Success = @('vm1')
                Failed = @()
                Skipped = @()
                Parallel = $false
            }

            $summary = Write-LabOperationSummary -Operation 'Start' -Result $result

            $summary.Timestamp | Should -Not -BeNullOrEmpty
            $summary.Operation | Should -Be 'Start'
            $summary.OverallStatus | Should -Be 'OK'
            $summary.FormattedSummary | Should -Not -BeNullOrEmpty
        }
    }
}
```

These tests verify the summary formatting functionality across bulk operations and workflow executions. Tests cover successful operations, operations with failures, duration formatting, workflow step details, and summary object properties. The test pattern follows Pester 5 conventions with Context blocks for logical grouping.
  </action>
  <verify>Invoke-Pester Tests/LabOperationSummary.Tests.ps1 -PassThru | Select-Object -ExpandProperty PassedCount is greater than 0</verify>
  <done>Unit tests exist and verify summary formatting correctness</done>
</task>

<task type="auto">
  <name>Add Write-LabOperationSummary to Private auto-discovery</name>
  <files>Lab-Common.ps1</files>
  <action>
Ensure Write-LabOperationSummary.ps1 is auto-discovered by Lab-Common.ps1.

Lab-Common.ps1 already dynamically discovers all Private/*.ps1 files using Get-ChildItem and dot-sourcing. Since Write-LabOperationSummary.ps1 is in the Private/ directory, it will be automatically sourced.

No changes are needed to Lab-Common.ps1. The auto-discovery pattern established in earlier phases handles new Private files automatically.

Verify this is working by checking that Lab-Common.ps1 contains the pattern:
```powershell
Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Exclude *.Tests.ps1 | ForEach-Object {
    . $_.FullName
}
```

This pattern ensures all Private functions (including Write-LabOperationSummary) are available for use by Public functions.
  </action>
  <verify>After importing module, Get-Command Write-LabOperationSummary -Module SimpleLab returns command info (function is discoverable)</verify>
  <done>Write-LabOperationSummary is auto-discovered via Lab-Common.ps1 Private/ pattern</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test summary writer: Write-LabOperationSummary creates formatted summary text
3. Test bulk operation integration: Invoke-LabBulkOperation includes Summary in result
4. Test workflow integration: Invoke-LabWorkflow includes Summary with step details
5. Test log to history: Summary files are created in .planning/run-logs/
6. Test formatting: Summary text includes status indicators, VM lists, error details
7. Run tests: Pester tests for summary functionality pass
</verification>

<success_criteria>
1. Write-LabOperationSummary formats summaries with header, status, breakdown, and footer
2. Bulk operation summaries show Success/Failed/Skipped VM counts with error details
3. Workflow summaries show per-step results with status indicators
4. Summaries are automatically displayed after operations complete
5. Summaries can be logged to run history for audit trail
6. Duration is formatted in mm:ss.fff format
7. Result objects include Summary property with FormattedSummary text
8. Unit tests verify summary formatting for all scenarios
9. Write-LabOperationSummary is discoverable via Lab-Common.ps1
</success_criteria>

<output>
After completion, create `.planning/phases/32-operational-workflows/32-04-SUMMARY.md` with:
- Actual files created with line counts
- Summary format examples
- Test coverage summary
- Any deviations from plan
- Phase 32 completion notes
- Next steps for Phase 33
</output>
