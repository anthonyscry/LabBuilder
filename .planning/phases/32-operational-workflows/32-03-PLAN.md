---
phase: 32-operational-workflows
plan: 03
type: execute
wave: 3
depends_on: ["32-01", "32-02"]
files_modified:
  - Public/Test-LabBulkOperation.ps1
  - Private/Test-LabBulkOperationCore.ps1
  - Tests/LabBulkOperationValidation.Tests.ps1
autonomous: true
requirements:
  - OPS-03

must_haves:
  truths:
    - "System validates bulk operations before execution (pre-flight checks, resource availability)"
    - "Test-LabBulkOperation performs validation without executing operations"
    - "Pre-flight checks include VM existence, Hyper-V module availability, resource constraints"
    - "Validation returns structured result with Pass/Warn/Fail statuses"
    - "Resource availability checks validate sufficient RAM/CPU for requested operations"
    - "Operator receives clear remediation guidance for failed checks"
  artifacts:
    - path: "Public/Test-LabBulkOperation.ps1"
      provides: "Public API for bulk operation pre-flight validation"
      exports: ["Test-LabBulkOperation"]
      min_lines: 70
    - path: "Private/Test-LabBulkOperationCore.ps1"
      provides: "Core validation logic for pre-flight checks"
      min_lines: 100
    - path: "Tests/LabBulkOperationValidation.Tests.ps1"
      provides: "Unit tests for pre-flight validation"
      min_lines: 60
  key_links:
    - from: "Test-LabBulkOperation.ps1"
      to: "Test-LabBulkOperationCore.ps1"
      via: "Delegates to core function for validation"
      pattern: "Test-LabBulkOperationCore"
    - from: "Test-LabBulkOperationCore.ps1"
      to: "Private/Get-LabHostResourceInfo.ps1"
      via: "Gets host resource info for availability checks"
      pattern: "Get-LabHostResourceInfo"
    - from: "Test-LabBulkOperationCore.ps1"
      to: "Hyper-V\Get-VM"
      via: "Validates VM existence before operations"
      pattern: "Get-VM"
---

<objective>
Create pre-flight validation infrastructure that validates bulk operations before execution, checking VM existence, Hyper-V module availability, and resource constraints to prevent failures and provide clear remediation guidance.

Purpose: Enable operators to validate bulk operations before execution, identifying potential issues like missing VMs, insufficient resources, or Hyper-V module problems that would cause operation failures.

Output: Test-LabBulkOperation public API, Test-LabBulkOperationCore validation logic with multiple check types, and unit tests covering all validation scenarios.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-operational-workflows/32-01-SUMMARY.md
@.planning/phases/32-operational-workflows/32-02-SUMMARY.md

# Existing patterns from codebase (for reference, not to copy)
Public/Test-LabConfigValidation.ps1 (Phase 15) - Shows validation pattern with PSCustomObject results
Private/Test-LabIso.ps1 (Phase 2) - Shows resource availability checking
Private/Get-LabHostResourceInfo.ps1 (Phase 17) - Shows host resource probing
Private/Invoke-LabQuickModeHeal.ps1 (Phase 26) - Shows pre-flight validation with remediation
</context>

<tasks>

<task type="auto">
  <name>Create Test-LabBulkOperationCore validation function</name>
  <files>Private/Test-LabBulkOperationCore.ps1</files>
  <action>
Create Private/Test-LabBulkOperationCore.ps1 with core validation logic:

```powershell
function Test-LabBulkOperationCore {
    <#
    .SYNOPSIS
        Validates pre-flight conditions for bulk VM operations.

    .DESCRIPTION
        Test-LabBulkOperationCore performs validation checks before bulk
        operations execute, including VM existence, Hyper-V module
        availability, and resource constraints. Returns structured
        results with Pass/Warn/Fail statuses and remediation guidance.

    .PARAMETER VMName
        Array of VM names to validate.

    .PARAMETER Operation
        Operation type to validate: 'Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint'.

    .PARAMETER CheckResourceAvailability
        Include resource availability checks (RAM/CPU) for Start operations.

    .OUTPUTS
        [pscustomobject] with OverallStatus (OK/Warning/Fail), Checks array,
        FailedChecks array, and remediation suggestions.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string[]]$VMName,

        [Parameter(Mandatory)]
        [ValidateSet('Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint')]
        [string]$Operation,

        [switch]$CheckResourceAvailability
    )

    $checks = [System.Collections.Generic.List[pscustomobject]]::new()
    $failCount = 0
    $warnCount = 0

    # Check 1: Hyper-V module availability
    $hvCheck = [ordered]@{
        Name    = 'Hyper-V Module'
        Status  = 'Pass'
        Message = 'Hyper-V module is available'
        Remediation = $null
    }

    try {
        $null = Get-Module -ListAvailable -Name Hyper-V -ErrorAction Stop
    }
    catch {
        $hvCheck.Status = 'Fail'
        $hvCheck.Message = 'Hyper-V module not found'
        $hvCheck.Remediation = 'Install Hyper-V module: Install-Module -Name Hyper-V -Force'
        $failCount++
    }

    $checks.Add([pscustomobject]$hvCheck)

    # Check 2: VM existence
    $vmCheck = [ordered]@{
        Name    = 'VM Existence'
        Status  = 'Pass'
        Message = "All $($VMName.Count) VMs exist"
        Remediation = $null
    }

    try {
        $missingVMs = [System.Collections.Generic.List[string]]::new()
        $foundVMs = [System.Collections.Generic.List[string]]::new()

        foreach ($vmName in $VMName) {
            try {
                $vm = Get-VM -Name $vmName -ErrorAction Stop
                $foundVMs.Add($vmName)
            }
            catch {
                $missingVMs.Add($vmName)
            }
        }

        if ($missingVMs.Count -gt 0) {
            $vmCheck.Status = 'Fail'
            $vmCheck.Message = "$($missingVMs.Count) of $($VMName.Count) VMs not found: $($missingVMs -join ', ')"
            $vmCheck.Remediation = "Verify VM names or create missing VMs: $($missingVMs -join ', ')"
            $failCount++
        }
        else {
            $vmCheck.Message = "All $($VMName.Count) VMs found: $($foundVMs -join ', ')"
        }
    }
    catch {
        $vmCheck.Status = 'Fail'
        $vmCheck.Message = "Failed to query VMs: $($_.Exception.Message)"
        $vmCheck.Remediation = 'Ensure Hyper-V service is running and you have administrative permissions'
        $failCount++
    }

    $checks.Add([pscustomobject]$vmCheck)

    # Check 3: Operation-specific validation
    $opCheck = [ordered]@{
        Name    = 'Operation Validation'
        Status  = 'Pass'
        Message = "Operation '$Operation' is valid for target VMs"
        Remediation = $null
    }

    try {
        if ($foundVMs.Count -gt 0) {
            $invalidVMs = [System.Collections.Generic.List[string]]::new()

            foreach ($vmName in $foundVMs) {
                try {
                    $vm = Get-VM -Name $vmName -ErrorAction Stop

                    switch ($Operation) {
                        'Start' {
                            if ($vm.State -eq 'Running') {
                                $invalidVMs.Add("$vmName (already running)")
                            }
                        }
                        'Stop' {
                            if ($vm.State -eq 'Off') {
                                $invalidVMs.Add("$vmName (already off)")
                            }
                        }
                        'Suspend' {
                            if ($vm.State -ne 'Running') {
                                $invalidVMs.Add("$vmName (state: $($vm.State))")
                            }
                        }
                        'Restart' {
                            if ($vm.State -eq 'Off') {
                                $invalidVMs.Add("$vmName (VM is off)")
                            }
                        }
                        'Checkpoint' {
                            if ($vm.State -eq 'Off') {
                                $invalidVMs.Add("$vmName (VM is off)")
                            }
                        }
                    }
                }
                catch {
                    $invalidVMs.Add("$vmName (query failed)")
                }
            }

            if ($invalidVMs.Count -gt 0) {
                $opCheck.Status = 'Warn'
                $opCheck.Message = "$($invalidVMs.Count) VMs may not behave as expected: $($invalidVMs -join ', ')"
                $opCheck.Remediation = 'Review VM states before proceeding or use Force parameter if applicable'
                $warnCount++
            }
        }
    }
    catch {
        $opCheck.Status = 'Warn'
        $opCheck.Message = "Could not validate operation-specific conditions: $($_.Exception.Message)"
        $opCheck.Remediation = 'Proceed with caution; operation will validate at execution time'
        $warnCount++
    }

    $checks.Add([pscustomobject]$opCheck)

    # Check 4: Resource availability (for Start operations only)
    if ($Operation -eq 'Start' -and $CheckResourceAvailability) {
        $resourceCheck = [ordered]@{
            Name    = 'Resource Availability'
            Status  = 'Pass'
            Message = 'Sufficient resources available'
            Remediation = $null
        }

        try {
            $resourceInfo = Get-LabHostResourceInfo

            $requiredRAM = 0
            foreach ($vmName in $foundVMs) {
                try {
                    $vm = Get-VM -Name $vmName -ErrorAction Stop
                    $requiredRAM += [math]::Ceiling($vm.MemoryGB / 1GB)
                }
                catch {
                    # Assume 4GB default if VM can't be queried
                    $requiredRAM += 4
                }
            }

            if ($requiredRAM -gt $resourceInfo.FreeRAMGB) {
                $resourceCheck.Status = 'Warn'
                $resourceCheck.Message = "May require ~$requiredRAM GB RAM but only $($resourceInfo.FreeRAMGB) GB free"
                $resourceCheck.Remediation = 'Stop other VMs or add more RAM to host before proceeding'
                $warnCount++
            }
            else {
                $resourceCheck.Message = "Sufficient RAM: ~$requiredRAM GB required, $($resourceInfo.FreeRAMGB) GB free"
            }
        }
        catch {
            $resourceCheck.Status = 'Warn'
            $resourceCheck.Message = "Could not verify resource availability: $($_.Exception.Message)"
            $resourceCheck.Remediation = 'Manually verify host has sufficient RAM and CPU before starting VMs'
            $warnCount++
        }

        $checks.Add([pscustomobject]$resourceCheck)
    }

    # Determine overall status
    $overallStatus = switch ($failCount) {
        { $_ -gt 0 } { 'Fail' }
        { $warnCount -gt 0 } { 'Warning' }
        default { 'OK' }
    }

    $failedChecks = @($checks | Where-Object { $_.Status -eq 'Fail' })

    return [pscustomobject]@{
        OverallStatus = $overallStatus
        Checks        = @($checks)
        FailedChecks  = $failedChecks
        Operation     = $Operation
        VMCount       = $VMName.Count
        Timestamp     = (Get-Date -Format 'o')
    }
}
```

This core function implements comprehensive pre-flight validation with four check categories: Hyper-V module availability, VM existence, operation-specific validation, and resource availability (optional). Each check returns a structured result with status, message, and remediation guidance. The overall status is determined based on fail/warn counts.
  </action>
  <verify>Test-LabBulkOperationCore -VMName @('testvm') -Operation 'Start' returns result object with OverallStatus, Checks array, and FailedChecks array</verify>
  <done>Test-LabBulkOperationCore function exists and performs pre-flight validation</done>
</task>

<task type="auto">
  <name>Create Test-LabBulkOperation public API</name>
  <files>Public/Test-LabBulkOperation.ps1</files>
  <action>
Create Public/Test-LabBulkOperation.ps1 as the public API:

```powershell
function Test-LabBulkOperation {
    <#
    .SYNOPSIS
        Validates pre-flight conditions for bulk VM operations.

    .DESCRIPTION
        Test-LabBulkOperation performs validation checks before executing
        bulk operations, ensuring VMs exist, Hyper-V is available, and
        sufficient resources exist. Returns structured results with
        Pass/Warn/Fail statuses and remediation guidance for any issues.

    .PARAMETER VMName
        One or more VM names to validate.

    .PARAMETER Operation
        Operation type to validate: 'Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint'.

    .PARAMETER CheckResourceAvailability
        Include resource availability checks for Start operations (adds RAM/CPU validation).

    .PARAMETER Remediation
        Display remediation guidance for failed checks.

    .EXAMPLE
        Test-LabBulkOperation -VMName @('dc1', 'svr1') -Operation Start
        Validates prerequisites for starting VMs.

    .EXAMPLE
        Test-LabBulkOperation -VMName (Get-LabVM) -Operation Start -CheckResourceAvailability
        Validates all lab VMs including resource checks.
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string[]]$VMName,

        [Parameter(Mandatory)]
        [ValidateSet('Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint')]
        [string]$Operation,

        [switch]$CheckResourceAvailability,

        [switch]$Remediation
    )

    begin {
        $allVMs = [System.Collections.Generic.List[string]]::new()
    }

    process {
        foreach ($vm in $VMName) {
            $allVMs.Add($vm)
        }
    }

    end {
        if ($allVMs.Count -eq 0) {
            Write-Warning 'No VMs specified for validation'
            return
        }

        $params = @{
            VMName = @($allVMs)
            Operation = $Operation
        }

        if ($CheckResourceAvailability) {
            $params.CheckResourceAvailability = $true
        }

        $result = Test-LabBulkOperationCore @params

        if ($Remediation -and $result.FailedChecks.Count -gt 0) {
            Write-Host "`nRemediation Guidance:" -ForegroundColor Cyan
            foreach ($check in $result.FailedChecks) {
                Write-Host "  [$($check.Name)]" -ForegroundColor Yellow
                Write-Host "    Problem: $($check.Message)" -ForegroundColor Gray
                if ($check.Remediation) {
                    Write-Host "    Fix: $($check.Remediation)" -ForegroundColor Green
                }
            }
        }

        Write-Verbose "Test-LabBulkOperation: OverallStatus = $($result.OverallStatus)"

        return $result
    }
}
```

This public API follows the pattern established by Test-LabConfigValidation (Phase 15). It provides pipeline input support, delegates to the Private core function, and includes optional Remediation parameter for formatted remediation guidance. The CheckResourceAvailability switch enables resource validation for Start operations where RAM/CPU constraints matter most.
  </action>
  <verify>Test-LabBulkOperation -VMName @('testvm') -Operation Start returns result object with OverallStatus and Checks array</verify>
  <done>Test-LabBulkOperation public API exists with pipeline support and remediation formatting</done>
</task>

<task type="auto">
  <name>Create unit tests for pre-flight validation</name>
  <files>Tests/LabBulkOperationValidation.Tests.ps1</files>
  <action>
Create Tests/LabBulkOperationValidation.Tests.ps1 with unit tests:

```powershell
Describe 'Test-LabBulkOperation' {
    BeforeAll {
        $moduleRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
        Import-Module "$moduleRoot\SimpleLab\SimpleLab.psd1" -Force

        . "$moduleRoot\Private\Test-LabBulkOperationCore.ps1"
    }

    Context 'Hyper-V module check' {
        It 'Passes when Hyper-V module is available' {
            Mock Get-Module { return $true } -ParameterFilter { $Name -eq 'Hyper-V' }

            $result = Test-LabBulkOperationCore -VMName @('test-vm') -Operation 'Start'

            $result.Checks[0].Name | Should -Be 'Hyper-V Module'
            $result.Checks[0].Status | Should -Be 'Pass'
        }

        It 'Fails when Hyper-V module not found' {
            Mock Get-Module { throw 'Module not found' }

            $result = Test-LabBulkOperationCore -VMName @('test-vm') -Operation 'Start'

            $result.Checks[0].Status | Should -Be 'Fail'
            $result.Checks[0].Remediation | Should -Not -BeNullOrEmpty
            $result.OverallStatus | Should -Be 'Fail'
        }
    }

    Context 'VM existence check' {
        It 'Passes when all VMs exist' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }

            $result = Test-LabBulkOperationCore -VMName @('vm1', 'vm2') -Operation 'Start'

            $vmCheck = $result.Checks | Where-Object { $_.Name -eq 'VM Existence' }
            $vmCheck.Status | Should -Be 'Pass'
        }

        It 'Fails when VMs are missing' {
            Mock Get-VM { throw "VM '$Name' not found" }

            $result = Test-LabBulkOperationCore -VMName @('missing-vm') -Operation 'Start'

            $vmCheck = $result.Checks | Where-Object { $_.Name -eq 'VM Existence' }
            $vmCheck.Status | Should -Be 'Fail'
            $vmCheck.Remediation | Should -Not -BeNullOrEmpty
        }
    }

    Context 'Operation validation' {
        It 'Warns when starting already-running VMs' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }

            $result = Test-LabBulkOperationCore -VMName @('running-vm') -Operation 'Start'

            $opCheck = $result.Checks | Where-Object { $_.Name -eq 'Operation Validation' }
            $opCheck.Status | Should -Be 'Warn'
        }

        It 'Warns when stopping already-stopped VMs' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }

            $result = Test-LabBulkOperationCore -VMName @('stopped-vm') -Operation 'Stop'

            $opCheck = $result.Checks | Where-Object { $_.Name -eq 'Operation Validation' }
            $opCheck.Status | Should -Be 'Warn'
        }

        It 'Passes operation validation for valid state transitions' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }

            $result = Test-LabBulkOperationCore -VMName @('stopped-vm') -Operation 'Start'

            $opCheck = $result.Checks | Where-Object { $_.Name -eq 'Operation Validation' }
            $opCheck.Status | Should -Be 'Pass'
        }
    }

    Context 'Resource availability check' {
        It 'Skips resource check when CheckResourceAvailability not specified' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }

            $result = Test-LabBulkOperationCore -VMName @('vm1') -Operation 'Start'

            $resourceCheck = $result.Checks | Where-Object { $_.Name -eq 'Resource Availability' }
            $resourceCheck | Should -BeNullOrEmpty
        }

        It 'Includes resource check when CheckResourceAvailability specified' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off'; MemoryGB = 4GB } }
            Mock Get-LabHostResourceInfo { return [pscustomobject]@{ FreeRAMGB = 16 } }

            $result = Test-LabBulkOperationCore -VMName @('vm1') -Operation 'Start' -CheckResourceAvailability

            $resourceCheck = $result.Checks | Where-Object { $_.Name -eq 'Resource Availability' }
            $resourceCheck | Should -Not -BeNullOrEmpty
        }

        It 'Warns when insufficient RAM for Start operation' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off'; MemoryGB = 16GB } }
            Mock Get-LabHostResourceInfo { return [pscustomobject]@{ FreeRAMGB = 8 } }

            $result = Test-LabBulkOperationCore -VMName @('vm1') -Operation 'Start' -CheckResourceAvailability

            $resourceCheck = $result.Checks | Where-Object { $_.Name -eq 'Resource Availability' }
            $resourceCheck.Status | Should -Be 'Warn'
        }
    }

    Context 'Overall status calculation' {
        It 'Returns Fail overall status when any check fails' {
            Mock Get-Module { throw 'Module not found' }

            $result = Test-LabBulkOperationCore -VMName @('vm1') -Operation 'Start'

            $result.OverallStatus | Should -Be 'Fail'
        }

        It 'Returns Warning overall status when checks warn but none fail' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }

            $result = Test-LabBulkOperationCore -VMName @('running-vm') -Operation 'Start'

            $result.OverallStatus | Should -Be 'Warning'
        }

        It 'Returns OK overall status when all checks pass' {
            Mock Get-Module { return $true }
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }

            $result = Test-LabBulkOperationCore -VMName @('vm1') -Operation 'Start'

            $result.OverallStatus | Should -Be 'OK'
        }
    }
}
```

These tests verify the pre-flight validation functionality across all check types. Tests cover Hyper-V module availability, VM existence, operation-specific validation, resource availability, and overall status calculation. The test pattern follows Pester 5 conventions with Context blocks for logical grouping and proper Mock usage for isolating the function under test.
  </action>
  <verify>Invoke-Pester Tests/LabBulkOperationValidation.Tests.ps1 -PassThru | Select-Object -ExpandProperty PassedCount is greater than 0</verify>
  <done>Unit tests exist and verify pre-flight validation correctness</done>
</task>

<task type="auto">
  <name>Add Test-LabBulkOperation to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export Test-LabBulkOperation.

In SimpleLab.psm1, add 'Test-LabBulkOperation' to the Export-ModuleMember array.
In SimpleLab.psd1, add 'Test-LabBulkOperation' to the FunctionsToExport array.

This follows the established pattern for public API functions and makes the pre-flight validation functionality available to operators.
  </action>
  <verify>Get-Command Test-LabBulkOperation -Module SimpleLab returns command info</verify>
  <done>Test-LabBulkOperation is exported from the SimpleLab module</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test core function: Test-LabBulkOperationCore validates all check types
3. Test public API: Test-LabBulkOperation returns result with OverallStatus and Checks array
4. Test remediation: Test-LabBulkOperation -Remediation displays formatted guidance
5. Test resource checks: Test-LabBulkOperation -CheckResourceAvailability includes RAM validation
6. Test pipeline: Get-LabVM | Test-LabBulkOperation -Operation Start works
7. Run tests: Pester tests for pre-flight validation pass
</verification>

<success_criteria>
1. Test-LabBulkOperationCore validates Hyper-V module availability
2. Test-LabBulkOperationCore validates VM existence before operations
3. Test-LabBulkOperationCore performs operation-specific validation (state checks)
4. Test-LabBulkOperationCore optionally checks resource availability for Start operations
5. Test-LabBulkOperation provides public API with remediation formatting
6. Each check includes status, message, and remediation guidance
7. Overall status correctly reflects fail/warn/pass state
8. Unit tests verify all validation check types
9. Test-LabBulkOperation is exported from SimpleLab module
</success_criteria>

<output>
After completion, create `.planning/phases/32-operational-workflows/32-03-SUMMARY.md` with:
- Actual files created with line counts
- Pre-flight check types documented
- Test coverage summary
- Any deviations from plan
- Next steps for Plan 32-04
</output>
