---
phase: 32-operational-workflows
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Public/Invoke-LabBulkOperation.ps1
  - Private/Invoke-LabBulkOperationCore.ps1
  - Tests/LabBulkOperation.Tests.ps1
autonomous: true
requirements:
  - OPS-01

must_haves:
  truths:
    - "Operator can perform bulk VM operations (start/stop/suspend multiple VMs at once)"
    - "Invoke-LabBulkOperation accepts VM list and operation type parameters"
    - "Bulk operations execute against each VM with per-VM error handling"
    - "Results object includes Success, Failed, and Skipped VM lists"
    - "Operations are processed in parallel where possible for efficiency"
  artifacts:
    - path: "Public/Invoke-LabBulkOperation.ps1"
      provides: "Public API for bulk VM operations"
      exports: ["Invoke-LabBulkOperation"]
      min_lines: 70
    - path: "Private/Invoke-LabBulkOperationCore.ps1"
      provides: "Core bulk operation execution logic"
      min_lines: 90
    - path: "Tests/LabBulkOperation.Tests.ps1"
      provides: "Unit tests for bulk operations"
      min_lines: 50
  key_links:
    - from: "Invoke-LabBulkOperation.ps1"
      to: "Invoke-LabBulkOperationCore.ps1"
      via: "Delegates to core function for execution"
      pattern: "Invoke-LabBulkOperationCore"
    - from: "Invoke-LabBulkOperationCore.ps1"
      to: "Hyper-V\Get-VM"
      via: "Uses Hyper-V cmdlets for VM operations"
      pattern: "Get-VM|Start-VM|Stop-VM|Suspend-VM"
---

<objective>
Create bulk VM operation infrastructure that enables operators to start, stop, suspend, or restart multiple VMs simultaneously with per-VM error handling and comprehensive result reporting.

Purpose: Enable efficient management of multiple VMs through a single command, reducing the operational overhead of managing VMs individually while providing clear feedback on which operations succeeded or failed.

Output: Invoke-LabBulkOperation public API with operation type validation, bulk operation core logic with parallel execution support, and unit tests covering success and failure scenarios.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns from codebase (for reference, not to copy)
Public/Start-LabVMs.ps1 (Phase 11) - Shows VM start operations with error handling
Public/Suspend-LabVMs.ps1 (Phase 11) - Shows suspend operations with per-VM try/catch
Private/Invoke-LabBulkVMProvision.ps1 (Phase 8) - Shows bulk iteration pattern
GUI/Start-OpenCodeLabGUI.ps1 (Phase 17) - Shows bulk action button handlers
</context>

<tasks>

<task type="auto">
  <name>Create Invoke-LabBulkOperationCore bulk execution function</name>
  <files>Private/Invoke-LabBulkOperationCore.ps1</files>
  <action>
Create Private/Invoke-LabBulkOperationCore.ps1 with core bulk operation logic:

```powershell
function Invoke-LabBulkOperationCore {
    <#
    .SYNOPSIS
        Executes bulk operations against multiple VMs.

    .DESCRIPTION
        Invoke-LabBulkOperationCore performs the specified operation (Start, Stop,
        Suspend, Restart, Checkpoint) against multiple VMs with per-VM error handling.
        Operations execute with parallel processing support and return detailed
        results including Success, Failed, and Skipped VM lists.

    .PARAMETER VMName
        Array of VM names to operate on.

    .PARAMETER Operation
        Operation type: 'Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint'.

    .PARAMETER CheckpointName
        Checkpoint name (required for 'Checkpoint' operation).

    .PARAMETER Parallel
        Execute operations in parallel (switch).

    .OUTPUTS
        [pscustomobject] with Success (vm[]), Failed (vm[],error[]), Skipped (vm[])
        arrays, OverallStatus (OK/Partial/Failed), Duration (timespan), and
        OperationCount (int).
    #>
    [CmdletBinding()]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory)]
        [string[]]$VMName,

        [Parameter(Mandatory)]
        [ValidateSet('Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint')]
        [string]$Operation,

        [string]$CheckpointName,

        [switch]$Parallel
    )

    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    $success = [System.Collections.Generic.List[string]]::new()
    $failed = [System.Collections.Generic.List[pscustomobject]]::new()
    $skipped = [System.Collections.Generic.List[string]]::new()

    $operationBlock = {
        param($vmName, $operation, $checkpointName)

        $ErrorActionPreference = 'Stop'

        try {
            $vm = Get-VM -Name $vmName -ErrorAction Stop

            switch ($operation) {
                'Start' {
                    if ($vm.State -eq 'Running') {
                        return @{ VMName = $vmName; Status = 'Skipped'; Reason = 'Already running' }
                    }
                    Start-VM -Name $vmName -ErrorAction Stop
                    return @{ VMName = $vmName; Status = 'Success' }
                }
                'Stop' {
                    if ($vm.State -eq 'Off') {
                        return @{ VMName = $vmName; Status = 'Skipped'; Reason = 'Already stopped' }
                    }
                    Stop-VM -Name $vmName -Force -ErrorAction Stop
                    return @{ VMName = $vmName; Status = 'Success' }
                }
                'Suspend' {
                    if ($vm.State -ne 'Running') {
                        return @{ VMName = $vmName; Status = 'Skipped'; Reason = "Not running (state: $($vm.State))" }
                    }
                    Suspend-VM -Name $vmName -ErrorAction Stop
                    return @{ VMName = $vmName; Status = 'Success' }
                }
                'Restart' {
                    if ($vm.State -eq 'Off') {
                        return @{ VMName = $vmName; Status = 'Skipped'; Reason = 'VM is off' }
                    }
                    Restart-VM -Name $vmName -Force -ErrorAction Stop
                    return @{ VMName = $vmName; Status = 'Success' }
                }
                'Checkpoint' {
                    if ([string]::IsNullOrWhiteSpace($checkpointName)) {
                        return @{ VMName = $vmName; Status = 'Failed'; Error = 'CheckpointName required' }
                    }
                    Checkpoint-VM -Name $vmName -SnapshotName $checkpointName -ErrorAction Stop
                    return @{ VMName = $vmName; Status = 'Success' }
                }
            }
        }
        catch {
            return @{ VMName = $vmName; Status = 'Failed'; Error = $_.Exception.Message }
        }
    }

    if ($Parallel) {
        $runspaces = [System.Collections.ArrayList]::new()
        $results = [System.Collections.ArrayList]::new()

        foreach ($vm in $VMName) {
            $powershell = [powershell]::Create().AddScript($operationBlock.ToString()).
                AddParameter('vmName', $vm).
                AddParameter('operation', $Operation).
                AddParameter('checkpointName', $CheckpointName)

            $handle = $powershell.BeginInvoke()
            $null = $runspaces.Add(@{ PS = $powershell; Handle = $handle; VM = $vm })
        }

        foreach ($rs in $runspaces) {
            try {
                $rs.Handle.EndInvoke($rs.Handle)
                $result = $rs.PS.EndInvoke($rs.Handle)
                $null = $results.Add($result)
            }
            catch {
                $null = $results.Add(@{
                    VMName = $rs.VM
                    Status = 'Failed'
                    Error = $_.Exception.Message
                })
            }
            finally {
                $rs.PS.Dispose()
            }
        }

        foreach ($result in $results) {
            switch ($result.Status) {
                'Success' { $success.Add($result.VMName) }
                'Skipped' { $skipped.Add("$($result.VMName) ($($result.Reason))") }
                'Failed' {
                    $failed.Add([pscustomobject]@{
                        VMName = $result.VMName
                        Error  = $result.Error
                    })
                }
            }
        }
    }
    else {
        foreach ($vm in $VMName) {
            try {
                $result = & $operationBlock -vmName $vm -operation $Operation -checkpointName $CheckpointName

                switch ($result.Status) {
                    'Success' { $success.Add($result.VMName) }
                    'Skipped' { $skipped.Add("$($result.VMName) ($($result.Reason))") }
                    'Failed' {
                        $failed.Add([pscustomobject]@{
                            VMName = $result.VMName
                            Error  = $result.Error
                        })
                    }
                }
            }
            catch {
                $failed.Add([pscustomobject]@{
                    VMName = $vm
                    Error  = $_.Exception.Message
                })
            }
        }
    }

    $stopwatch.Stop()

    $overallStatus = switch ($failed.Count) {
        { $_ -eq 0 } { 'OK' }
        { $_ -lt $VMName.Count } { 'Partial' }
        default { 'Failed' }
    }

    return [pscustomobject]@{
        Success       = @($success)
        Failed        = @($failed)
        Skipped       = @($skipped)
        OverallStatus = $overallStatus
        Operation     = $Operation
        OperationCount = $VMName.Count
        Duration      = $stopwatch.Elapsed
        Parallel      = $Parallel
    }
}
```

This core function implements the bulk operation execution logic with support for both sequential and parallel execution modes. It uses runspaces for parallel processing, following PowerShell best practices for multi-threaded operations. Each VM operation is isolated with per-VM error handling so one failure doesn't block other operations. The result structure provides detailed feedback for automation consumption.
  </action>
  <verify>Invoke-LabBulkOperationCore -VMName @('vm1','vm2') -Operation 'Start' returns result object with Success, Failed, Skipped arrays and OverallStatus property</verify>
  <done>Invoke-LabBulkOperationCore function exists and executes bulk operations with per-VM error handling</done>
</task>

<task type="auto">
  <name>Create Invoke-LabBulkOperation public API</name>
  <files>Public/Invoke-LabBulkOperation.ps1</files>
  <action>
Create Public/Invoke-LabBulkOperation.ps1 as the public API:

```powershell
function Invoke-LabBulkOperation {
    <#
    .SYNOPSIS
        Performs bulk operations against multiple lab VMs.

    .DESCRIPTION
        Invoke-LabBulkOperation starts, stops, suspends, restarts, or checkpoints
        multiple VMs in a single command. Operations execute with per-VM error
        handling so one failure doesn't block other VMs. Results include which
        VMs succeeded, failed, or were skipped with reasons.

    .PARAMETER VMName
        One or more VM names to operate on. Accepts pipeline input.

    .PARAMETER Operation
        Operation type: 'Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint'.

    .PARAMETER CheckpointName
        Checkpoint name (required for 'Checkpoint' operation).

    .PARAMETER Parallel
        Execute operations in parallel for faster completion on large VM sets.

    .PARAMETER WhatIf
        Shows what would happen without executing.

    .EXAMPLE
        Invoke-LabBulkOperation -VMName @('dc1', 'svr1', 'cli1') -Operation Start
        Starts three VMs sequentially.

    .EXAMPLE
        Invoke-LabBulkOperation -VMName @('dc1', 'svr1') -Operation Stop -Parallel
        Stops two VMs in parallel.

    .EXAMPLE
        Get-LabVM | Invoke-LabBulkOperation -Operation Suspend
        Suspends all lab VMs via pipeline.
    #>
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string[]]$VMName,

        [Parameter(Mandatory)]
        [ValidateSet('Start', 'Stop', 'Suspend', 'Restart', 'Checkpoint')]
        [string]$Operation,

        [Parameter(ParameterSetName = 'Checkpoint')]
        [string]$CheckpointName,

        [switch]$Parallel
    )

    begin {
        $allVMs = [System.Collections.Generic.List[string]]::new()
    }

    process {
        foreach ($vm in $VMName) {
            $allVMs.Add($vm)
        }
    }

    end {
        if ($allVMs.Count -eq 0) {
            Write-Warning 'No VMs specified for bulk operation'
            return
        }

        $targetList = $allVMs -join ', '
        if (-not $PSCmdlet.ShouldProcess($targetList, $Operation)) {
            return
        }

        $params = @{
            VMName    = @($allVMs)
            Operation = $Operation
            Parallel  = $Parallel
        }

        if ($PSBoundParameters.ContainsKey('CheckpointName')) {
            $params.CheckpointName = $CheckpointName
        }

        $result = Invoke-LabBulkOperationCore @params

        Write-Verbose "Invoke-LabBulkOperation: $($result.Operation) - OverallStatus: $($result.OverallStatus)"
        Write-Verbose "Success: $($result.Success.Count), Failed: $($result.Failed.Count), Skipped: $($result.Skipped.Count)"
        Write-Verbose "Duration: $($result.Duration.ToString('mm\:ss\.fff'))"

        if ($result.Failed.Count -gt 0) {
            foreach ($failure in $result.Failed) {
                Write-Warning "Invoke-LabBulkOperation: $($failure.VMName) failed - $($failure.Error)"
            }
        }

        if ($result.Skipped.Count -gt 0) {
            foreach ($skip in $result.Skipped) {
                Write-Verbose "Invoke-LabBulkOperation: Skipped $skip"
            }
        }

        return $result
    }
}
```

This public API follows the pattern established by other Public functions in the codebase. It provides ShouldProcess support for -WhatIf safety, accepts pipeline input for VM names (enabling Get-LabVM | Invoke-LabBulkOperation patterns), and delegates to the Private core function for actual execution. The ParameterSetName ensures CheckpointName is only accepted when Operation is 'Checkpoint'.
  </action>
  <verify>Invoke-LabBulkOperation -VMName @('testvm1','testvm2') -Operation Start -WhatIf returns without executing and shows WhatIf output</verify>
  <done>Invoke-LabBulkOperation public API exists with proper parameter validation and ShouldProcess support</done>
</task>

<task type="auto">
  <name>Create unit tests for bulk operations</name>
  <files>Tests/LabBulkOperation.Tests.ps1</files>
  <action>
Create Tests/LabBulkOperation.Tests.ps1 with unit tests:

```powershell
Describe 'Invoke-LabBulkOperation' {
    BeforeAll {
        $moduleRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
        Import-Module "$moduleRoot\SimpleLab\SimpleLab.psd1" -Force

        . "$moduleRoot\Private\Invoke-LabBulkOperationCore.ps1"

        $mockVMs = @(
            @{ Name = 'test-vm1'; State = 'Off' }
            @{ Name = 'test-vm2'; State = 'Running' }
            @{ Name = 'test-vm3'; State = 'Off' }
        )
    }

    Context 'Sequential execution' {
        It 'Processes all VMs sequentially when Parallel not specified' {
            Mock Get-VM {
                $state = switch ($Name) {
                    'test-vm1' { 'Off' }
                    'test-vm2' { 'Running' }
                    'test-vm3' { 'Off' }
                }
                return [pscustomobject]@{ Name = $Name; State = $state }
            }

            Mock Start-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1', 'test-vm3') -Operation 'Start'

            $result.OperationCount | Should -Be 2
            $result.Parallel | Should -BeFalse
        }

        It 'Returns success results for successful operations' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Off' } }
            Mock Start-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1') -Operation 'Start'

            $result.Success.Count | Should -Be 1
            $result.Success[0] | Should -Be 'test-vm1'
        }

        It 'Returns skipped results for already-running VMs on start' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm2') -Operation 'Start'

            $result.Skipped.Count | Should -Be 1
            $result.Skipped[0] | Should -Match 'test-vm2.*Already running'
        }
    }

    Context 'Parallel execution' {
        It 'Processes VMs in parallel when Parallel specified' {
            Mock Get-VM {
                $state = switch ($Name) {
                    'test-vm1' { 'Off' }
                    'test-vm2' { 'Off' }
                    'test-vm3' { 'Off' }
                }
                return [pscustomobject]@{ Name = $Name; State = $state }
            }
            Mock Start-VM { Start-Sleep -Milliseconds 100; return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1', 'test-vm2', 'test-vm3') -Operation 'Start' -Parallel

            $result.Parallel | Should -BeTrue
            $result.Success.Count | Should -Be 3
        }
    }

    Context 'Error handling' {
        It 'Continues processing after individual VM failure' {
            Mock Get-VM {
                if ($Name -eq 'test-vm1') {
                    throw 'VM not found'
                }
                return [pscustomobject]@{ Name = $Name; State = 'Off' }
            }
            Mock Start-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1', 'test-vm2') -Operation 'Start'

            $result.Failed.Count | Should -Be 1
            $result.Success.Count | Should -Be 1
            $result.OverallStatus | Should -Be 'Partial'
        }

        It 'Returns Failed overall status when all operations fail' {
            Mock Get-VM { throw 'All VMs not found' }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1', 'test-vm2') -Operation 'Start'

            $result.OverallStatus | Should -Be 'Failed'
            $result.Failed.Count | Should -Be 2
        }
    }

    Context 'Operation types' {
        It 'Supports Stop operation' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }
            Mock Stop-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1') -Operation 'Stop'

            $result.Operation | Should -Be 'Stop'
            $result.Success.Count | Should -Be 1
            Should -Invoke Stop-VM -Times 1
        }

        It 'Supports Suspend operation' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }
            Mock Suspend-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1') -Operation 'Suspend'

            $result.Operation | Should -Be 'Suspend'
            $result.Success.Count | Should -Be 1
        }

        It 'Supports Restart operation' {
            Mock Get-VM { return [pscustomobject]@{ Name = $Name; State = 'Running' } }
            Mock Restart-VM { return $null }

            $result = Invoke-LabBulkOperationCore -VMName @('test-vm1') -Operation 'Restart'

            $result.Operation | Should -Be 'Restart'
            $result.Success.Count | Should -Be 1
        }
    }
}
```

These tests verify the core bulk operation functionality across multiple scenarios. Tests cover sequential and parallel execution modes, success/skipped/failed result handling, and all supported operation types. The test pattern follows Pester 5 conventions with BeforeAll for setup and Context blocks for logical grouping. Mock objects simulate Hyper-V VM objects without requiring the actual Hyper-V module.
  </action>
  <verify>Invoke-Pester Tests/LabBulkOperation.Tests.ps1 -PassThru | Select-Object -ExpandProperty PassedCount is greater than 0</verify>
  <done>Unit tests exist and verify bulk operation correctness</done>
</task>

<task type="auto">
  <name>Add Invoke-LabBulkOperation to module exports</name>
  <files>SimpleLab.psm1, SimpleLab.psd1</files>
  <action>
Update both SimpleLab.psm1 and SimpleLab.psd1 to export Invoke-LabBulkOperation.

In SimpleLab.psm1, add 'Invoke-LabBulkOperation' to the Export-ModuleMember array.
In SimpleLab.psd1, add 'Invoke-LabBulkOperation' to the FunctionsToExport array.

This follows the established pattern for public API functions and makes the bulk operation functionality available to operators.
  </action>
  <verify>Get-Command Invoke-LabBulkOperation -Module SimpleLab returns command info</verify>
  <done>Invoke-LabBulkOperation is exported from the SimpleLab module</done>
</task>

</tasks>

<verification>
1. Import module: `Import-Module ./SimpleLab/SimpleLab.psd1` succeeds
2. Test core function: Invoke-LabBulkOperationCore executes operations against multiple VMs
3. Test public API: Invoke-LabBulkOperation returns result object with Success/Failed/Skipped arrays
4. Test parallel mode: Invoke-LabBulkOperation -Parallel processes VMs concurrently
5. Test pipeline: Get-LabVM | Invoke-LabBulkOperation -Operation Stop works
6. Run tests: Pester tests for bulk operations pass
</verification>

<success_criteria>
1. Invoke-LabBulkOperationCore executes all operation types (Start/Stop/Suspend/Restart/Checkpoint)
2. Invoke-LabBulkOperation provides public API with pipeline support and ShouldProcess
3. Bulk operations include per-VM error handling (one failure doesn't block others)
4. Parallel execution mode is available for large VM sets
5. Result object includes Success, Failed, Skipped arrays and OverallStatus
6. Unit tests verify bulk operation behavior
7. Invoke-LabBulkOperation is exported from SimpleLab module
</success_criteria>

<output>
After completion, create `.planning/phases/32-operational-workflows/32-01-SUMMARY.md` with:
- Actual files created with line counts
- Parallel execution implementation details
- Test coverage summary
- Any deviations from plan
- Next steps for Plan 32-02
</output>
