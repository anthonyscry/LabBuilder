---
phase: 09-error-handling
plan: 02
type: execute
wave: 1
depends_on: ["09-01"]
files_modified:
  - Private/Get-LabDomainConfig.ps1
  - Private/Get-LabNetworkConfig.ps1
  - Private/Get-LabVMConfig.ps1
  - Private/Get-GitIdentity.ps1
  - Private/Get-HostInfo.ps1
  - Private/Get-LabGuiDestructiveGuard.ps1
  - Private/New-LabAppArgumentList.ps1
  - Private/New-LabCoordinatorPlan.ps1
  - Private/New-LabUnattendXml.ps1
  - Private/Resolve-LabSqlPassword.ps1
  - Tests/ErrorHandling-Batch2.Tests.ps1
autonomous: true
requirements:
  - ERR-01
  - ERR-03

must_haves:
  truths:
    - "All 10 configuration and data-building Private functions have outer try-catch blocks"
    - "Error messages include the function name as a prefix for grep-ability"
    - "Config-building functions use throw (failures mean invalid lab state)"
    - "Guard and password functions use $PSCmdlet.WriteError (non-critical)"
    - "All existing Pester tests pass after changes (no behavior regression)"
  artifacts:
    - path: "Private/Get-LabVMConfig.ps1"
      provides: "try-catch wrapping complex VM config building"
    - path: "Private/New-LabUnattendXml.ps1"
      provides: "try-catch wrapping XML generation"
    - path: "Tests/ErrorHandling-Batch2.Tests.ps1"
      provides: "Tests verifying error handling pattern for all 10 functions"
  key_links:
    - from: "Private/Get-LabVMConfig.ps1"
      to: "Private/Get-LabDomainConfig.ps1"
      via: "VM config depends on domain config"
      pattern: "try.*catch"
---

<objective>
Add try-catch error handling to 10 Private configuration and data-building functions (Batch 2 of 4).

Purpose: These functions build configuration objects, generate XML, resolve credentials, and gather host information. Structured error handling ensures config-building failures produce messages that tell the user exactly which config element is wrong.

Output: 10 updated Private/*.ps1 files with try-catch, plus ErrorHandling-Batch2.Tests.ps1 verifying the pattern.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-error-handling/09-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add try-catch to config-building functions (5 files)</name>
  <files>Private/Get-LabDomainConfig.ps1, Private/Get-LabNetworkConfig.ps1, Private/Get-LabVMConfig.ps1, Private/Get-GitIdentity.ps1, Private/Get-HostInfo.ps1</files>
  <action>
    Wrap the function body (everything after param block) in a try-catch block for each file.

    **Pattern for config functions (Get-LabDomainConfig, Get-LabNetworkConfig, Get-LabVMConfig -- failures mean invalid lab state):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        throw "FunctionName: <context> - $_"
    }
    ```

    **Pattern for info-gathering functions (Get-GitIdentity, Get-HostInfo -- non-critical):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        $PSCmdlet.WriteError(
            [System.Management.Automation.ErrorRecord]::new(
                [System.Exception]::new("FunctionName: <context> - $_", $_.Exception),
                'FunctionName.Failure',
                [System.Management.Automation.ErrorCategory]::NotSpecified,
                $null
            )
        )
    }
    ```

    Context messages:
    - Get-LabDomainConfig: "failed to build domain configuration"
    - Get-LabNetworkConfig: "failed to build network configuration"
    - Get-LabVMConfig: "failed to build VM configuration"
    - Get-GitIdentity: "failed to retrieve git identity"
    - Get-HostInfo: "failed to gather host information"
  </action>
  <verify>
    Verify try-catch and function name in error messages for each file.
  </verify>
  <done>5 config-building functions have try-catch with function-name-prefixed error messages.</done>
</task>

<task type="auto">
  <name>Task 2: Add try-catch to data generation functions (5 files)</name>
  <files>Private/Get-LabGuiDestructiveGuard.ps1, Private/New-LabAppArgumentList.ps1, Private/New-LabCoordinatorPlan.ps1, Private/New-LabUnattendXml.ps1, Private/Resolve-LabSqlPassword.ps1</files>
  <action>
    Wrap the function body in try-catch for each file.

    **Pattern for critical functions (New-LabUnattendXml, New-LabAppArgumentList -- failures should halt):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        throw "FunctionName: <context> - $_"
    }
    ```

    **Pattern for non-critical functions (Get-LabGuiDestructiveGuard, New-LabCoordinatorPlan, Resolve-LabSqlPassword):**
    ```powershell
    try {
        # existing function body
    }
    catch {
        $PSCmdlet.WriteError(
            [System.Management.Automation.ErrorRecord]::new(
                [System.Exception]::new("FunctionName: <context> - $_", $_.Exception),
                'FunctionName.Failure',
                [System.Management.Automation.ErrorCategory]::NotSpecified,
                $null
            )
        )
    }
    ```

    Context messages:
    - Get-LabGuiDestructiveGuard: "destructive guard check failed"
    - New-LabAppArgumentList: "failed to build argument list"
    - New-LabCoordinatorPlan: "failed to create coordinator plan"
    - New-LabUnattendXml: "failed to generate unattend XML"
    - Resolve-LabSqlPassword: "failed to resolve SQL password"

    IMPORTANT: New-LabUnattendXml already has a Write-Warning call (added in Phase 7). Preserve that -- put the try-catch around the entire body including the Write-Warning.
  </action>
  <verify>
    Check each file contains try-catch with function name in error message.
  </verify>
  <done>5 data generation functions have try-catch with function-name-prefixed error messages.</done>
</task>

<task type="auto">
  <name>Task 3: Create ErrorHandling-Batch2.Tests.ps1</name>
  <files>Tests/ErrorHandling-Batch2.Tests.ps1</files>
  <action>
    Create a Pester 5.x test file that verifies all 10 functions have try-catch with proper error message patterns.

    Same structure as Batch 1 tests: iterate over file list, verify try-catch presence and function-name-in-error-message pattern.

    Use `Set-StrictMode -Version Latest` in BeforeAll. Follow project test patterns.
  </action>
  <verify>
    ```powershell
    Invoke-Pester Tests/ErrorHandling-Batch2.Tests.ps1 -Output Detailed
    ```
    All tests pass.
  </verify>
  <done>ErrorHandling-Batch2.Tests.ps1 exists with tests for all 10 functions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `Invoke-Pester Tests/ErrorHandling-Batch2.Tests.ps1 -Output Detailed` -- all tests pass
2. All 10 files have try-catch with function name in error messages
3. Full test suite: `Invoke-Pester Tests/ -Output Detailed` -- no regressions
</verification>

<success_criteria>
- All 10 configuration and data-building Private functions have try-catch error handling
- Error messages include function name prefix (ERR-03)
- Config-critical functions use throw, non-critical use $PSCmdlet.WriteError
- Full test suite passes without regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-error-handling/09-02-SUMMARY.md`
</output>
